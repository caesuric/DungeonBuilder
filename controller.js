// Generated by CoffeeScript 1.10.0
(function() {
  var Adventurer, BigMonster, CanvasInitializer, Dungeon, Map, Monster, Room, SmallMonster, app, unitTypes,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CanvasInitializer = {
    initCanvas: function() {
      var mainCanvasContainer;
      window.viewSize = 512;
      mainCanvasContainer = document.getElementById('mainCanvasContainer');
      mainCanvasContainer.style.width = this.viewSize;
      mainCanvasContainer.style.height = this.viewSize;
      window.canvas = new fabric.Canvas('mainCanvas', {
        width: this.viewSize,
        height: this.viewSize
      });
      window.canvas.backgroundColor = "black";
      window.canvas.selection = false;
      window.canvas.stateful = false;
      window.canvas.renderOnAddRemove = false;
      return window.canvas.renderAll();
    }
  };

  app = angular.module('dungeonBuilder', ['ui.bootstrap']);

  app.service('dungeon', Dungeon = (function() {
    function Dungeon($rootScope) {
      this.checkForEmptySpace = bind(this.checkForEmptySpace, this);
      this.pickRandomWall = bind(this.pickRandomWall, this);
      this.digRoom = bind(this.digRoom, this);
      this.adjustMaxPopulation = bind(this.adjustMaxPopulation, this);
      this.addMonsterToRoom = bind(this.addMonsterToRoom, this);
      this.allocateRoom = bind(this.allocateRoom, this);
      this.narrate = bind(this.narrate, this);
      this.defeatAdventurer = bind(this.defeatAdventurer, this);
      this.numActiveMonsters = bind(this.numActiveMonsters, this);
      this.monsterWithLowestHp = bind(this.monsterWithLowestHp, this);
      this.anyMonstersActive = bind(this.anyMonstersActive, this);
      this.doCombat = bind(this.doCombat, this);
      this.encounterMonsters = bind(this.encounterMonsters, this);
      this.runDungeon = bind(this.runDungeon, this);
      this.optimizeRemoval = bind(this.optimizeRemoval, this);
      this.upgradeAcolytes = bind(this.upgradeAcolytes, this);
      this.upgradeMinions = bind(this.upgradeMinions, this);
      this.sellBigAcolyte = bind(this.sellBigAcolyte, this);
      this.sellSmallAcolyte = bind(this.sellSmallAcolyte, this);
      this.sellAcolyte = bind(this.sellAcolyte, this);
      this.sellBigMonster = bind(this.sellBigMonster, this);
      this.sellSmallMonster = bind(this.sellSmallMonster, this);
      this.sellMonster = bind(this.sellMonster, this);
      this.sellBigMinion = bind(this.sellBigMinion, this);
      this.sellSmallMinion = bind(this.sellSmallMinion, this);
      this.sellMinion = bind(this.sellMinion, this);
      this.buyAllBigAcolytes = bind(this.buyAllBigAcolytes, this);
      this.buyAllSmallAcolytes = bind(this.buyAllSmallAcolytes, this);
      this.buyAllAcolytes = bind(this.buyAllAcolytes, this);
      this.buyAllBigMonsters = bind(this.buyAllBigMonsters, this);
      this.buyAllSmallMonsters = bind(this.buyAllSmallMonsters, this);
      this.buyAllMonsters = bind(this.buyAllMonsters, this);
      this.buyAllBigMinions = bind(this.buyAllBigMinions, this);
      this.buyAllSmallMinions = bind(this.buyAllSmallMinions, this);
      this.buyAllMinions = bind(this.buyAllMinions, this);
      this.buyBigAcolyte = bind(this.buyBigAcolyte, this);
      this.buySmallAcolyte = bind(this.buySmallAcolyte, this);
      this.buyAcolyte = bind(this.buyAcolyte, this);
      this.buyBigMonster = bind(this.buyBigMonster, this);
      this.buySmallMonster = bind(this.buySmallMonster, this);
      this.buyMonster = bind(this.buyMonster, this);
      this.buyBigMinion = bind(this.buyBigMinion, this);
      this.buySmallMinion = bind(this.buySmallMinion, this);
      this.buyMinion = bind(this.buyMinion, this);
      this.maxNumberToBuy = bind(this.maxNumberToBuy, this);
      this.monstersActive = bind(this.monstersActive, this);
      this.availablePopulation = bind(this.availablePopulation, this);
      this.emptyRooms = bind(this.emptyRooms, this);
      this.maxPopulation = bind(this.maxPopulation, this);
      this.totalPopulation = bind(this.totalPopulation, this);
      this.roomCost = bind(this.roomCost, this);
      this.bigUnitETA = bind(this.bigUnitETA, this);
      this.smallUnitETA = bind(this.smallUnitETA, this);
      this.unitETA = bind(this.unitETA, this);
      this.roomETA = bind(this.roomETA, this);
      this.upgradeAcolytesText = bind(this.upgradeAcolytesText, this);
      this.upgradeMinionsText = bind(this.upgradeMinionsText, this);
      this.updateRoomBox = bind(this.updateRoomBox, this);
      this.bigUnitProgressPercent = bind(this.bigUnitProgressPercent, this);
      this.smallUnitProgressPercent = bind(this.smallUnitProgressPercent, this);
      this.unitProgressPercent = bind(this.unitProgressPercent, this);
      this.roomProgressPercent = bind(this.roomProgressPercent, this);
      this.reputationRate = bind(this.reputationRate, this);
      this.updateValues = bind(this.updateValues, this);
      this.tick = bind(this.tick, this);
      var i, k, l, m, ref, ref1;
      this.rootScope = $rootScope;
      this.minions = 5;
      this.smallMinions = 0;
      this.bigMinions = 0;
      this.monsters = 5;
      this.smallMonsters = 0;
      this.bigMonsters = 0;
      this.monsterObjects = [];
      for (i = k = 0, ref = this.monsters - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.monsterObjects[i] = new Monster();
      }
      this.acolytes = 5;
      this.smallAcolytes = 0;
      this.bigAcolytes = 0;
      this.treasure = 10;
      $(document).ready(function() {
        return CanvasInitializer.initCanvas();
      });
      this.map = new Map();
      for (i = l = 1; l <= 4; i = ++l) {
        this.digRoom();
      }
      this.roomProgress = 0;
      this.rooms = 5;
      this.roomObjects = [];
      this.roomObjects[0] = new Room();
      this.roomObjects[0].population = 5;
      this.roomObjects[0].occupantType = unitTypes.minion;
      this.roomObjects[1] = new Room();
      this.roomObjects[1].population = 5;
      this.roomObjects[1].occupantType = unitTypes.monster;
      this.roomObjects[1].population = 5;
      for (i = m = 0, ref1 = this.monsters - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
        this.roomObjects[1].monsters[i] = this.monsterObjects[i];
      }
      this.roomObjects[2] = new Room();
      this.roomObjects[2].occupantType = unitTypes.acolyte;
      this.roomObjects[2].population = 5;
      this.roomObjects[3] = new Room();
      this.roomObjects[4] = new Room();
      this.adventurers = 0;
      this.reputation = 0;
      this.devMultiplier = 1;
      this.minionMultiplier = 1;
      this.acolyteMultiplier = 1;
      this.minionUpgradeCost = Math.floor(15000 * 0.2);
      this.acolyteUpgradeCost = Math.floor(15000 * 0.2);
      this.cost = 1500;
      setInterval(this.tick, 100);
    }

    Dungeon.prototype.tick = function() {
      var i, k, len, monster, ref, results;
      this.updateValues();
      this.updateRoomBox();
      this.updateRoomCanvas();
      ref = this.monsterObjects;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = this.devMultiplier - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            results1.push(monster.tick());
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Dungeon.prototype.updateValues = function() {
      var adventurerRoll, i, k, ref;
      this.roomProgress += ((this.smallMinions / 4) + this.minions + (this.bigMinions * 4)) * this.devMultiplier * this.minionMultiplier;
      if (this.roomProgress >= this.roomCost()) {
        this.roomProgress -= this.roomCost();
        this.rooms += 1;
        this.roomObjects[this.rooms - 1] = new Room();
        this.digRoom();
      }
      this.reputation += ((this.smallAcolytes / 4) + this.acolytes + (this.bigAcolytes * 4)) * this.devMultiplier * this.acolyteMultiplier;
      for (i = k = 0, ref = Math.floor(this.treasure * this.devMultiplier) - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        adventurerRoll = Math.floor((Math.random() * 14500) + 1);
        if (adventurerRoll === 14500) {
          this.runDungeon();
        }
      }
      return this.rootScope.$apply();
    };

    Dungeon.prototype.reputationRate = function() {
      return Math.floor(((this.smallAcolytes * 2.5) + (this.acolytes * 10) + (this.bigAcolytes * 40)) * this.acolyteMultiplier);
    };

    Dungeon.prototype.roomProgressPercent = function() {
      return (this.roomProgress / this.roomCost() * 100).toString();
    };

    Dungeon.prototype.unitProgressPercent = function() {
      if (this.reputation > this.cost && this.reputationRate() > this.cost) {
        return '100';
      }
      return ((this.reputation % this.cost) / this.cost * 100).toString();
    };

    Dungeon.prototype.smallUnitProgressPercent = function() {
      if (this.reputation > Math.floor(this.cost / 4) && this.reputationRate() > Math.floor(this.cost / 4)) {
        return '100';
      }
      return ((this.reputation % Math.floor(this.cost / 4)) / Math.floor(this.cost / 4) * 100).toString();
    };

    Dungeon.prototype.bigUnitProgressPercent = function() {
      if (this.reputation > Math.floor(this.cost * 2.8) && this.reputationRate() > Math.floor(this.cost * 2.8)) {
        return '100';
      }
      return ((this.reputation % Math.floor(this.cost * 2.8)) / Math.floor(this.cost * 2.8) * 100).toString();
    };

    Dungeon.prototype.updateRoomBox = function() {
      var i, k, ref, room, text;
      text = "Room Summary:<br><br>";
      for (i = k = 0, ref = this.rooms - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        room = this.roomObjects[i];
        text += "Room " + (i + 1).toString() + ":<br>Contains ";
        if (room.occupantType === unitTypes.none) {
          text += "nothing";
        } else if (room.occupantType === unitTypes.minion) {
          text += "minions";
        } else if (room.occupantType === unitTypes.smallMinion) {
          text += "mini-ons";
        } else if (room.occupantType === unitTypes.bigMinion) {
          text += "big minions";
        } else if (room.occupantType === unitTypes.monster) {
          text += "monsters";
        } else if (room.occupantType === unitTypes.smallMonster) {
          text += "small monsters";
        } else if (room.occupantType === unitTypes.bigMonster) {
          text += "big monsters";
        } else if (room.occupantType === unitTypes.acolyte) {
          text += "acolytes";
        } else if (room.occupantType === unitTypes.smallAcolyte) {
          text += "small acolytes";
        } else if (room.occupantType === unitTypes.bigAcolyte) {
          text += "big acolytes";
        }
        text += ".<br>Population: " + room.population.toString() + "/" + room.size.toString() + "<br><br>";
      }
      return document.getElementById('roomsPanel').innerHTML = text;
    };

    Dungeon.prototype.upgradeMinionsText = function() {
      return "Upgrade Minions (" + this.minionUpgradeCost + " reputation)";
    };

    Dungeon.prototype.upgradeAcolytesText = function() {
      return "Upgrade Acolytes (" + this.acolyteUpgradeCost + " reputation)";
    };

    Dungeon.prototype.roomETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = this.roomCost() - this.roomProgress;
      rate = ((this.smallMinions / 4) + this.minions + (this.bigMinions * 4)) * this.devMultiplier * this.minionMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.unitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = this.cost - (this.reputation % this.cost);
      rate = ((this.smallAcolytes / 4) + this.acolytes + (this.bigAcolytes * 4)) * this.devMultiplier * this.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.smallUnitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = Math.floor(this.cost / 4) - (this.reputation % Math.floor(this.cost / 4));
      rate = ((this.smallAcolytes / 4) + this.acolytes + (this.bigAcolytes * 4)) * this.devMultiplier * this.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.bigUnitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = Math.floor(this.cost * 2.8) - (this.reputation % Math.floor(this.cost * 2.8));
      rate = ((this.smallAcolytes / 4) + this.acolytes + (this.bigAcolytes * 4)) * this.devMultiplier * this.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.updateProgressBar = function(bar, percent) {
      return bar.width(percent + "%");
    };

    Dungeon.prototype.updateRoomCanvas = function() {
      var i, j, k, l, ref, ref1;
      window.canvas.clear();
      for (i = k = 0, ref = this.map.sizeX - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        for (j = l = 0, ref1 = this.map.sizeY - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
          if (this.map.tiles[i][j] === 'W') {
            window.canvas.add(new fabric.Rect({
              left: i * 8,
              top: j * 8,
              height: 8,
              width: 8,
              stroke: 'gray',
              fill: 'gray',
              strokeWidth: 2,
              selectable: false
            }));
          }
        }
      }
      return window.canvas.renderAll();
    };

    Dungeon.prototype.roomCost = function() {
      var costToBuild;
      costToBuild = 12240;
      if (this.rooms >= 100) {
        costToBuild = 1328065992;
      } else if (this.rooms >= 30) {
        costToBuild = 6324123;
      } else if (this.rooms >= 20) {
        costToBuild = 799632;
      }
      return costToBuild;
    };

    Dungeon.prototype.totalPopulation = function() {
      var bigUnits, normalUnits, smallUnits;
      smallUnits = this.smallMinions + this.smallMonsters + this.smallAcolytes;
      normalUnits = this.minions + this.monsters + this.acolytes;
      bigUnits = this.bigMinions + this.bigMonsters + this.bigAcolytes;
      return (smallUnits * 5) + (normalUnits * 10) + (bigUnits * 25);
    };

    Dungeon.prototype.maxPopulation = function() {
      return this.rooms * 50;
    };

    Dungeon.prototype.emptyRooms = function() {
      var count, k, len, ref, room;
      count = 0;
      ref = this.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.population === 0) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.availablePopulation = function() {
      return Math.max(this.maxPopulation() - this.totalPopulation(), 0);
    };

    Dungeon.prototype.monstersActive = function() {
      var count, k, len, monster, ref;
      count = 0;
      ref = this.monsterObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.maxNumberToBuy = function(cost) {
      return Math.min(Math.floor(this.reputation / cost), this.availablePopulation());
    };

    Dungeon.prototype.buyMinion = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.minion)) {
          this.minions += 1;
          return this.reputation -= this.cost;
        }
      }
    };

    Dungeon.prototype.buySmallMinion = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMinion)) {
          this.smallMinions += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigMinion = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMinion)) {
          this.bigMinions += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyMonster = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.monster)) {
          this.reputation -= this.cost;
          return this.monsters += 1;
        }
      }
    };

    Dungeon.prototype.buySmallMonster = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMonster)) {
          this.smallMonsters += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigMonster = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMonster)) {
          this.bigMonsters += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyAcolyte = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.acolyte)) {
          this.reputation -= this.cost;
          return this.acolytes += 1;
        }
      }
    };

    Dungeon.prototype.buySmallAcolyte = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallAcolyte)) {
          this.smallAcolytes += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigAcolyte = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigAcolyte)) {
          this.bigAcolytes += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyAllMinions = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallMinions = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buySmallMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigMinions = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyBigMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllMonsters = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallMonsters = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buySmallMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigMonsters = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyBigMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllAcolytes = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyAcolyte());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallAcolytes = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buySmallAcolyte());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigAcolytes = function() {
      var i, k, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.buyBigAcolyte());
      }
      return results;
    };

    Dungeon.prototype.sellMinion = function() {
      if (this.minions > 1) {
        this.minions -= 1;
        return this.optimizeRemoval(unitTypes.minion);
      }
    };

    Dungeon.prototype.sellSmallMinion = function() {
      if (this.smallMinions > 0) {
        this.smallMinions -= 1;
        return this.optimizeRemoval(unitTypes.smallMinion);
      }
    };

    Dungeon.prototype.sellBigMinion = function() {
      if (this.bigMinions > 0) {
        this.bigMinions -= 1;
        return this.optimizeRemoval(unitTypes.bigMinion);
      }
    };

    Dungeon.prototype.sellMonster = function() {
      if (this.monsters > 0) {
        this.monsters -= 1;
        return this.optimizeRemoval(unitTypes.monster);
      }
    };

    Dungeon.prototype.sellSmallMonster = function() {
      if (this.smallMonsters > 0) {
        this.smallMonsters -= 1;
        return this.optimizeRemoval(unitTypes.smallMonster);
      }
    };

    Dungeon.prototype.sellBigMonster = function() {
      if (this.bigMonsters > 0) {
        this.bigMonsters -= 1;
        return this.optimizeRemoval(unitTypes.bigMonster);
      }
    };

    Dungeon.prototype.sellAcolyte = function() {
      if (this.acolytes > 1) {
        this.acolytes -= 1;
        return this.optimizeRemoval(unitTypes.acolyte);
      }
    };

    Dungeon.prototype.sellSmallAcolyte = function() {
      if (this.smallAcolytes > 0) {
        this.smallAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.smallAcolyte);
      }
    };

    Dungeon.prototype.sellBigAcolyte = function() {
      if (this.bigAcolytes > 0) {
        this.bigAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.bigAcolyte);
      }
    };

    Dungeon.prototype.upgradeMinions = function() {
      if (this.reputation >= this.minionUpgradeCost) {
        this.reputation -= this.minionUpgradeCost;
        this.minionMultiplier = this.minionMultiplier * 1.2;
        return this.minionUpgradeCost = Math.floor(this.minionUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.upgradeAcolytes = function() {
      if (this.reputation >= this.acolyteUpgradeCost) {
        this.reputation -= this.acolyteUpgradeCost;
        this.acolyteMultiplier = this.acolyteMultiplier * 1.2;
        return this.acolyteUpgradeCost = Math.floor(this.acolyteUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.optimizeRemoval = function(type) {
      var k, len, ref, room, roomSelected;
      roomSelected = null;
      ref = this.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType !== type) {
          continue;
        }
        if (roomSelected === null && room.population > 0) {
          roomSelected = room;
        } else if (room.population < roomSelected.population && room.population > 0) {
          roomSelected = room;
        }
      }
      roomSelected.population -= 1;
      if (roomSelected.population === 0) {
        return roomSelected.occupantType = unitTypes.none;
      }
    };

    Dungeon.prototype.runDungeon = function() {
      var adventurer, k, len, ref, room;
      this.narrate('An adventurer arrives!');
      adventurer = new Adventurer();
      ref = this.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === unitTypes.monster) {
          if (this.encounterMonsters(adventurer, room)) {
            return;
          }
        }
      }
      if (this.treasure > 1) {
        this.treasure -= 1;
        return this.narrate('The adventurer has successfully beaten all of your monsters! They take one of your treasures!');
      } else {
        return this.narrate('The adventurer finds nothing and leaves.');
      }
    };

    Dungeon.prototype.encounterMonsters = function(adventurer, room) {
      this.doCombat(adventurer, room);
      if (adventurer.hp <= 0) {
        this.defeatAdventurer(room);
        return true;
      } else {
        return false;
      }
    };

    Dungeon.prototype.doCombat = function(adventurer, room) {
      var k, len, monster, ref, results, turnRoll;
      if (this.anyMonstersActive(room)) {
        turnRoll = Math.floor((Math.random() * 2) + 1);
        results = [];
        while (adventurer.hp > 0 && this.anyMonstersActive(room)) {
          if (turnRoll === 1) {
            monster = this.monsterWithLowestHp(room);
            monster.hp -= Math.floor((Math.random() * 8) + 3);
            turnRoll = 2;
            if (monster.hp <= 0) {
              monster.hp = 0;
              monster.health = 0;
              results.push(this.narrate('One of your monsters has been disabled by an adventurer.'));
            } else {
              results.push(void 0);
            }
          } else if (turnRoll === 2) {
            ref = room.monsters;
            for (k = 0, len = ref.length; k < len; k++) {
              monster = ref[k];
              adventurer.hp -= Math.max(Math.floor((Math.random() * 12) + 4 + monster.damage), 0);
            }
            results.push(turnRoll = 1);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    Dungeon.prototype.anyMonstersActive = function(room) {
      var k, len, monster, ref;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.monsterWithLowestHp = function(room) {
      var k, len, lowestHp, monster, monsterSelected, ref;
      lowestHp = 1000000;
      monsterSelected = null;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.hp < lowestHp && monster.isActive()) {
          lowestHp = monster.hp;
          monsterSelected = monster;
        }
      }
      return monsterSelected;
    };

    Dungeon.prototype.numActiveMonsters = function(room) {
      var count, k, len, monster, ref;
      count = 0;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.defeatAdventurer = function(room) {
      var k, len, monster, ref, type, xp;
      this.adventurers += 1;
      this.treasure += 1;
      xp = Math.floor(100 / this.numActiveMonsters(room));
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          monster.xp += xp;
          monster.checkForLevelUp();
        }
      }
      if (room.occupantType === unitTypes.monster) {
        type = "monsters";
      } else if (room.occupantType === unitTypes.smallMonster) {
        type = "small monsters";
      } else if (room.occupantType === unitTypes.bigMonster) {
        type = "big monsters";
      }
      return this.narrate('Some of your ' + type + ' have slain the adventurer! You take their treasure!');
    };

    Dungeon.prototype.narrate = function(text) {
      document.getElementById('narrationContainer').innerHTML += '<br>' + text;
      return document.getElementById('narrationContainer').scrollTop = document.getElementById('narrationContainer').scrollHeight;
    };

    Dungeon.prototype.allocateRoom = function(type) {
      var k, len, ref, room;
      ref = this.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === unitTypes.none) {
          room.occupantType = type;
          room.population += 1;
          this.addMonsterToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        } else if (room.occupantType === type && room.population < room.size) {
          room.population += 1;
          this.addMonsterToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.addMonsterToRoom = function(room) {
      var monster;
      if (room.occupantType === unitTypes.monster || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.bigMonster) {
        if (room.occupantType === unitTypes.monster) {
          monster = new Monster();
        } else if (room.occupantType === unitTypes.smallMonster) {
          monster = new SmallMonster();
        } else if (room.occupantType === unitTypes.bigMonster) {
          monster = new BigMonster();
        }
        this.monsterObjects[this.monsters + this.smallMonsters + this.bigMonsters] = monster;
        return room.monsters[room.population - 1] = monster;
      }
    };

    Dungeon.prototype.adjustMaxPopulation = function(room) {
      if (room.occupantType === unitTypes.smallMinion || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.smallAcolyte) {
        return room.size = 10;
      } else if (room.occupantType === unitTypes.bigMinion || room.occupantType === unitTypes.bigMonster || room.occupantType === unitTypes.bigAcolyte) {
        return room.size = 2;
      } else {
        return room.size = 5;
      }
    };

    Dungeon.prototype.digRoom = function() {
      var facing, ref, result, results, x, y;
      result = false;
      results = [];
      while (result === false) {
        ref = this.pickRandomWall(), x = ref[0], y = ref[1], facing = ref[2];
        results.push(result = this.map.excavate(x, y, facing));
      }
      return results;
    };

    Dungeon.prototype.pickRandomWall = function() {
      var facing, x, y;
      facing = null;
      while (facing === null) {
        x = Math.floor(Math.random() * (this.map.sizeX - (this.map.border * 2) - 1)) + this.map.border;
        y = Math.floor(Math.random() * (this.map.sizeY - (this.map.border * 2) - 1)) + this.map.border;
        facing = this.checkForEmptySpace(x, y);
      }
      return [x, y, facing];
    };

    Dungeon.prototype.checkForEmptySpace = function(x, y) {
      if (this.map.tiles[x][y + 1] === ' ') {
        return 2;
      }
      if (this.map.tiles[x - 1][y] === ' ') {
        return 3;
      }
      if (this.map.tiles[x][y - 1] === ' ') {
        return 0;
      }
      if (this.map.tiles[x + 1][y] === ' ') {
        return 1;
      }
      return null;
    };

    return Dungeon;

  })());

  app.controller('main', function($scope, dungeon) {
    $scope.dungeon = dungeon;
    $scope.reputation = 0;
    $scope.reputationRate = 0;
    $scope.minions = 0;
    $scope.smallMinions = 0;
    $scope.bigMinions = 0;
    $scope.buyAllMinionsText = "";
    $scope.buyAllSmallMinionsText = "";
    $scope.buyAllBigMinionsText = "";
    $scope.population = 0;
    $scope.maxPopulation = 0;
    $scope.roomProgressPercent = 0;
    $scope.roomProgressPercentRounded = 0;
    $scope.unitProgressPercent = 0;
    $scope.unitProgressPercentRounded = 0;
    $scope.smallUnitProgressPercent = 0;
    $scope.smallUnitProgressPercentRounded = 0;
    $scope.bigUnitProgressPercent = 0;
    $scope.bigUnitProgressPercentRounded = 0;
    $scope.rooms = 0;
    $scope.alerts = [];
    $scope.roomETA = "";
    $scope.unitETA = "";
    $scope.smallUnitETA = "";
    $scope.bigUnitETA = "";
    $scope.monsters = 0;
    $scope.smallMonsters = 0;
    $scope.bigMonsters = 0;
    $scope.monstersActive = 0;
    $scope.buyAllMonstersText = "";
    $scope.buyAllSmallMonstersText = "";
    $scope.BuyAllBigMonstersText = "";
    $scope.acolytes = 0;
    $scope.smallAcolytes = 0;
    $scope.bigAcolytes = 0;
    $scope.buyAllAcolytesText = "";
    $scope.buyAllSmallAcolytesText = "";
    $scope.buyAllBigAcolytesText = "";
    $scope.adventurers = 0;
    $scope.treasure = 0;
    $scope.upgradeMinionsText = "";
    $scope.upgradeAcolytesText = "";
    $scope.emptyRooms = 0;
    $scope.$watch('dungeon.reputation', function(newVal) {
      $scope.reputation = Math.floor(newVal);
      $scope.buyAllMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(dungeon.cost)) + ")";
      $scope.buyAllSmallMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost / 4))) + ")";
      $scope.buyAllBigMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost * 2.8))) + ")";
      $scope.buyAllMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(dungeon.cost)) + ")";
      $scope.buyAllSmallMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost / 4))) + ")";
      $scope.buyAllBigMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost * 2.8))) + ")";
      $scope.buyAllAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(dungeon.cost)) + ")";
      $scope.buyAllSmallAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost / 4))) + ")";
      return $scope.buyAllBigAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(Math.floor(dungeon.cost * 2.8))) + ")";
    });
    $scope.$watch('dungeon.reputationRate()', function(newVal) {
      return $scope.reputationRate = newVal;
    });
    $scope.$watch('dungeon.minions', function(newVal) {
      return $scope.minions = newVal;
    });
    $scope.$watch('dungeon.smallMinions', function(newVal) {
      return $scope.smallMinions = newVal;
    });
    $scope.$watch('dungeon.bigMinions', function(newVal) {
      return $scope.bigMinions = newVal;
    });
    $scope.$watch('dungeon.totalPopulation()', function(newVal) {
      return $scope.population = newVal;
    });
    $scope.$watch('dungeon.maxPopulation()', function(newVal) {
      return $scope.maxPopulation = newVal;
    });
    $scope.$watch('dungeon.roomProgressPercent()', function(newVal) {
      $scope.roomProgressPercent = newVal;
      return $scope.roomProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.unitProgressPercent()', function(newVal) {
      $scope.unitProgressPercent = newVal;
      return $scope.unitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.smallUnitProgressPercent()', function(newVal) {
      $scope.smallUnitProgressPercent = newVal;
      return $scope.smallUnitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.bigUnitProgressPercent()', function(newVal) {
      $scope.bigUnitProgressPercent = newVal;
      return $scope.bigUnitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.rooms', function(newVal) {
      $scope.rooms = newVal;
      if ($scope.rooms > 5) {
        return $scope.alerts.push({
          type: 'success',
          msg: 'Room constructed!'
        });
      }
    });
    $scope.$watch('dungeon.roomETA()', function(newVal) {
      return $scope.roomETA = newVal;
    });
    $scope.$watch('dungeon.unitETA()', function(newVal) {
      return $scope.unitETA = newVal;
    });
    $scope.$watch('dungeon.smallUnitETA()', function(newVal) {
      return $scope.smallUnitETA = newVal;
    });
    $scope.$watch('dungeon.bigUnitETA()', function(newVal) {
      return $scope.bigUnitETA = newVal;
    });
    $scope.$watch('dungeon.monsters', function(newVal) {
      return $scope.monsters = newVal;
    });
    $scope.$watch('dungeon.smallMonsters', function(newVal) {
      return $scope.smallMonsters = newVal;
    });
    $scope.$watch('dungeon.bigMonsters', function(newVal) {
      return $scope.bigMonsters = newVal;
    });
    $scope.$watch('dungeon.monstersActive()', function(newVal) {
      return $scope.monstersActive = newVal;
    });
    $scope.$watch('dungeon.acolytes', function(newVal) {
      return $scope.acolytes = newVal;
    });
    $scope.$watch('dungeon.smallAcolytes', function(newVal) {
      return $scope.smallAcolytes = newVal;
    });
    $scope.$watch('dungeon.bigAcolytes', function(newVal) {
      return $scope.bigAcolytes = newVal;
    });
    $scope.$watch('dungeon.adventurers', function(newVal) {
      return $scope.adventurers = newVal;
    });
    $scope.$watch('dungeon.treasure', function(newVal) {
      return $scope.treasure = newVal;
    });
    $scope.$watch('dungeon.upgradeMinionsText()', function(newVal) {
      return $scope.upgradeMinionsText = newVal;
    });
    $scope.$watch('dungeon.upgradeAcolytesText()', function(newVal) {
      return $scope.upgradeAcolytesText = newVal;
    });
    $scope.$watch('dungeon.emptyRooms()', function(newVal) {
      return $scope.emptyRooms = newVal;
    });
    return $scope.closeAlert = function(index) {
      return $scope.alerts.splice(index, 1);
    };
  });

  Monster = (function() {
    function Monster() {
      this.levelUp = bind(this.levelUp, this);
      this.checkForLevelUp = bind(this.checkForLevelUp, this);
      this.tick = bind(this.tick, this);
      this.isActive = bind(this.isActive, this);
      this.maxHealth = 2400;
      this.health = 2400;
      this.hp = 15;
      this.maxHp = 15;
      this.xp = 0;
      this.level = 1;
      this.damage = 0;
    }

    Monster.prototype.isActive = function() {
      if (this.health === this.maxHealth) {
        return true;
      } else {
        return false;
      }
    };

    Monster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 160) + 1);
        if (roll === 160) {
          return this.hp += 1;
        }
      }
    };

    Monster.prototype.checkForLevelUp = function() {
      var k, len, level, results, tier, xpTable;
      xpTable = [300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];
      level = 1;
      for (k = 0, len = xpTable.length; k < len; k++) {
        tier = xpTable[k];
        if (this.xp > tier) {
          level += 1;
        } else {
          break;
        }
      }
      if (level > this.level) {
        results = [];
        while (level > this.level) {
          results.push(this.levelUp());
        }
        return results;
      }
    };

    Monster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return Monster;

  })();

  SmallMonster = (function(superClass) {
    extend(SmallMonster, superClass);

    function SmallMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      SmallMonster.__super__.constructor.call(this);
      this.hp = 4;
      this.maxHp = 4;
      this.damage = -7;
    }

    SmallMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 640) + 1);
        if (roll === 640) {
          return this.hp += 1;
        }
      }
    };

    SmallMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your small monsters has attained level ' + this.level.toString() + '!');
      this.hp += 2;
      this.maxHp += 2;
      return this.damage += 1;
    };

    return SmallMonster;

  })(Monster);

  BigMonster = (function(superClass) {
    extend(BigMonster, superClass);

    function BigMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      BigMonster.__super__.constructor.call(this);
      this.hp = 60;
      this.maxHp = 60;
      this.damage = 30;
    }

    BigMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 40) + 1);
        if (roll === 40) {
          return this.hp += 1;
        }
      }
    };

    BigMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your big monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return BigMonster;

  })(Monster);

  Adventurer = (function() {
    function Adventurer() {
      this.hp = 13;
    }

    return Adventurer;

  })();

  Room = (function() {
    function Room() {
      this.population = 0;
      this.size = 5;
      this.occupantType = unitTypes.none;
      this.monsters = [];
    }

    return Room;

  })();

  Map = (function() {
    function Map() {
      this.determineBounds = bind(this.determineBounds, this);
      this.determineStep = bind(this.determineStep, this);
      this.checkOpenings = bind(this.checkOpenings, this);
      this.excavateDoor = bind(this.excavateDoor, this);
      this.sizeX = 64;
      this.sizeY = 64;
      this.roomDimensions = 5;
      this.tiles = [];
      this.border = 1;
      this.initFillMap();
      this.digInitialRoom();
    }

    Map.prototype.initFillMap = function() {
      var i, j, k, ref, results;
      results = [];
      for (i = k = 0, ref = this.sizeX - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.tiles[i] = [];
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (j = l = 0, ref1 = this.sizeY - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            results1.push(this.tiles[i][j] = 'W');
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Map.prototype.digInitialRoom = function() {
      var i, j, k, ref, ref1, results, rollX, rollY;
      rollX = Math.floor((Math.random() * (this.sizeX - (this.border * 2) - this.roomDimensions) - 1) + this.border);
      rollY = Math.floor((Math.random() * (this.sizeY - (this.border * 2) - this.roomDimensions) - 1) + this.border);
      results = [];
      for (i = k = ref = rollX, ref1 = rollX + this.roomDimensions - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
        results.push((function() {
          var l, ref2, ref3, results1;
          results1 = [];
          for (j = l = ref2 = rollY, ref3 = rollY + this.roomDimensions - 1; ref2 <= ref3 ? l <= ref3 : l >= ref3; j = ref2 <= ref3 ? ++l : --l) {
            results1.push(this.tiles[i][j] = ' ');
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Map.prototype.excavate = function(x, y, facing) {
      var i, j, k, l, m, n, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, xMax, xStep, yMax, yStep;
      ref = this.determineStep(facing), xStep = ref[0], yStep = ref[1];
      ref1 = this.determineBounds(x, y, xStep, yStep, facing), xMax = ref1[0], yMax = ref1[1];
      for (i = k = ref2 = x, ref3 = xMax, ref4 = xStep; ref4 > 0 ? k <= ref3 : k >= ref3; i = k += ref4) {
        for (j = l = ref5 = y, ref6 = yMax, ref7 = yStep; ref7 > 0 ? l <= ref6 : l >= ref6; j = l += ref7) {
          if (this.tiles[i] === void 0) {
            return false;
          }
          if (this.tiles[i][j] !== 'W') {
            return false;
          }
        }
      }
      ref8 = this.excavateDoor(x, y, xStep, yStep, facing), x = ref8[0], y = ref8[1];
      for (i = m = ref9 = x, ref10 = xMax, ref11 = xStep; ref11 > 0 ? m <= ref10 : m >= ref10; i = m += ref11) {
        for (j = n = ref12 = y, ref13 = yMax, ref14 = yStep; ref14 > 0 ? n <= ref13 : n >= ref13; j = n += ref14) {
          this.tiles[i][j] = ' ';
        }
      }
      return true;
    };

    Map.prototype.excavateDoor = function(x, y, xStep, yStep, facing) {
      var valid, xDoor, yDoor;
      valid = false;
      while (valid === false) {
        if (facing === 0 || facing === 2) {
          xDoor = Math.floor(Math.random() * 5) + x;
          yDoor = y;
        } else if (facing === 1 || facing === 3) {
          xDoor = x;
          yDoor = Math.floor(Math.random() * 5) + y;
        }
        valid = this.checkOpenings(xDoor, yDoor);
      }
      this.tiles[xDoor][yDoor] = ' ';
      if (facing === 0 || facing === 2) {
        y += yStep;
      } else if (facing === 1 || facing === 3) {
        x += xStep;
      }
      return [x, y];
    };

    Map.prototype.checkOpenings = function(x, y) {
      var count;
      count = 0;
      if (this.tiles[x - 1][y] === ' ') {
        count += 1;
      }
      if (this.tiles[x + 1][y] === ' ') {
        count += 1;
      }
      if (this.tiles[x][y - 1] === ' ') {
        count += 1;
      }
      if (this.tiles[x][y + 1] === ' ') {
        count += 1;
      }
      console.log(count);
      if (count === 1) {
        return true;
      }
      return false;
    };

    Map.prototype.determineStep = function(facing) {
      if (facing === 0) {
        return [1, 1];
      }
      if (facing === 1) {
        return [-1, 1];
      }
      if (facing === 2) {
        return [1, -1];
      }
      if (facing === 3) {
        return [1, 1];
      }
    };

    Map.prototype.determineBounds = function(x, y, xStep, yStep, facing) {
      if (facing === 0 || facing === 2) {
        return [x + (xStep * (this.roomDimensions - 1)), y + (yStep * this.roomDimensions)];
      }
      if (facing === 1 || facing === 3) {
        return [x + (xStep * this.roomDimensions), y + (yStep * (this.roomDimensions - 1))];
      }
    };

    return Map;

  })();

  unitTypes = {
    none: -1,
    minion: 0,
    monster: 1,
    acolyte: 2,
    smallMinion: 3,
    bigMinion: 4,
    smallMonster: 5,
    bigMonster: 6,
    smallAcolyte: 7,
    bigAcolyte: 8
  };

}).call(this);

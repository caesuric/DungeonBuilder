// Generated by CoffeeScript 1.10.0
(function() {
  var Acolyte, Adventurer, BigAcolyte, BigMinion, BigMonster, CanvasInitializer, Dungeon, DungeonData, HugeAcolyte, HugeMinion, HugeMonster, Map, Minion, Monster, Room, RoomConnection, SmallAcolyte, SmallMinion, SmallMonster, app, guid, unitTypes,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CanvasInitializer = {
    initCanvas: function() {
      var mainCanvasContainer;
      window.viewSize = 768;
      mainCanvasContainer = document.getElementById('mainCanvasContainer');
      mainCanvasContainer.style.width = this.viewSize;
      mainCanvasContainer.style.height = this.viewSize;
      window.canvas = new fabric.Canvas('mainCanvas', {
        width: this.viewSize,
        height: this.viewSize
      });
      window.canvas.backgroundColor = "black";
      window.canvas.selection = false;
      window.canvas.stateful = false;
      window.canvas.renderOnAddRemove = false;
      window.canvas.skipTargetFind = true;
      return window.canvas.renderAll();
    }
  };

  app = angular.module('dungeonBuilder', ['ui.bootstrap', 'ngCookies', 'ngAnimate']);

  app.service('dungeon', Dungeon = (function() {
    function Dungeon($rootScope) {
      this.checkIfConnectionExists = bind(this.checkIfConnectionExists, this);
      this.roomsAdjacent = bind(this.roomsAdjacent, this);
      this.checkDoorAdjacency = bind(this.checkDoorAdjacency, this);
      this.findDoors = bind(this.findDoors, this);
      this.roomsConnected = bind(this.roomsConnected, this);
      this.formRoomConnections = bind(this.formRoomConnections, this);
      this.checkForEmptySpace = bind(this.checkForEmptySpace, this);
      this.pickRandomWall = bind(this.pickRandomWall, this);
      this.digRoom = bind(this.digRoom, this);
      this.adjustMaxPopulation = bind(this.adjustMaxPopulation, this);
      this.addUnitObjectToRoom = bind(this.addUnitObjectToRoom, this);
      this.allocateRoom = bind(this.allocateRoom, this);
      this.narrate = bind(this.narrate, this);
      this.defeatAdventurer = bind(this.defeatAdventurer, this);
      this.numActiveMonsters = bind(this.numActiveMonsters, this);
      this.monsterWithLowestHp = bind(this.monsterWithLowestHp, this);
      this.anyMonstersActive = bind(this.anyMonstersActive, this);
      this.doCombat = bind(this.doCombat, this);
      this.encounterMonsters = bind(this.encounterMonsters, this);
      this.traverseRooms = bind(this.traverseRooms, this);
      this.runDungeon = bind(this.runDungeon, this);
      this.optimizeRemoval = bind(this.optimizeRemoval, this);
      this.upgradeAcolytes = bind(this.upgradeAcolytes, this);
      this.upgradeMinions = bind(this.upgradeMinions, this);
      this.sellHugeAcolyte = bind(this.sellHugeAcolyte, this);
      this.sellBigAcolyte = bind(this.sellBigAcolyte, this);
      this.sellSmallAcolyte = bind(this.sellSmallAcolyte, this);
      this.sellAcolyte = bind(this.sellAcolyte, this);
      this.sellHugeMonster = bind(this.sellHugeMonster, this);
      this.sellBigMonster = bind(this.sellBigMonster, this);
      this.sellSmallMonster = bind(this.sellSmallMonster, this);
      this.sellMonster = bind(this.sellMonster, this);
      this.sellHugeMinion = bind(this.sellHugeMinion, this);
      this.sellBigMinion = bind(this.sellBigMinion, this);
      this.sellSmallMinion = bind(this.sellSmallMinion, this);
      this.sellMinion = bind(this.sellMinion, this);
      this.calculateRoomCapacityForSellAll = bind(this.calculateRoomCapacityForSellAll, this);
      this.calculateRoomCapacityForBuyAll = bind(this.calculateRoomCapacityForBuyAll, this);
      this.sellRoomOfBigAcolytes = bind(this.sellRoomOfBigAcolytes, this);
      this.sellRoomOfAcolytes = bind(this.sellRoomOfAcolytes, this);
      this.sellRoomOfSmallAcolytes = bind(this.sellRoomOfSmallAcolytes, this);
      this.sellRoomOfBigMonsters = bind(this.sellRoomOfBigMonsters, this);
      this.sellRoomOfMonsters = bind(this.sellRoomOfMonsters, this);
      this.sellRoomOfSmallMonsters = bind(this.sellRoomOfSmallMonsters, this);
      this.sellRoomOfBigMinions = bind(this.sellRoomOfBigMinions, this);
      this.sellRoomOfMinions = bind(this.sellRoomOfMinions, this);
      this.sellRoomOfSmallMinions = bind(this.sellRoomOfSmallMinions, this);
      this.buyRoomOfBigAcolytes = bind(this.buyRoomOfBigAcolytes, this);
      this.buyRoomOfAcolytes = bind(this.buyRoomOfAcolytes, this);
      this.buyRoomOfSmallAcolytes = bind(this.buyRoomOfSmallAcolytes, this);
      this.buyRoomOfBigMonsters = bind(this.buyRoomOfBigMonsters, this);
      this.buyRoomOfMonsters = bind(this.buyRoomOfMonsters, this);
      this.buyRoomOfSmallMonsters = bind(this.buyRoomOfSmallMonsters, this);
      this.buyRoomOfBigMinions = bind(this.buyRoomOfBigMinions, this);
      this.buyRoomOfMinions = bind(this.buyRoomOfMinions, this);
      this.buyRoomOfSmallMinions = bind(this.buyRoomOfSmallMinions, this);
      this.buyAllHugeAcolytes = bind(this.buyAllHugeAcolytes, this);
      this.buyAllBigAcolytes = bind(this.buyAllBigAcolytes, this);
      this.buyAllSmallAcolytes = bind(this.buyAllSmallAcolytes, this);
      this.buyAllAcolytes = bind(this.buyAllAcolytes, this);
      this.buyAllHugeMonsters = bind(this.buyAllHugeMonsters, this);
      this.buyAllBigMonsters = bind(this.buyAllBigMonsters, this);
      this.buyAllSmallMonsters = bind(this.buyAllSmallMonsters, this);
      this.buyAllMonsters = bind(this.buyAllMonsters, this);
      this.buyAllHugeMinions = bind(this.buyAllHugeMinions, this);
      this.buyAllBigMinions = bind(this.buyAllBigMinions, this);
      this.buyAllSmallMinions = bind(this.buyAllSmallMinions, this);
      this.buyAllMinions = bind(this.buyAllMinions, this);
      this.buyHugeAcolyte = bind(this.buyHugeAcolyte, this);
      this.buyBigAcolyte = bind(this.buyBigAcolyte, this);
      this.buySmallAcolyte = bind(this.buySmallAcolyte, this);
      this.buyAcolyte = bind(this.buyAcolyte, this);
      this.buyHugeMonster = bind(this.buyHugeMonster, this);
      this.buyBigMonster = bind(this.buyBigMonster, this);
      this.buySmallMonster = bind(this.buySmallMonster, this);
      this.buyMonster = bind(this.buyMonster, this);
      this.buyHugeMinion = bind(this.buyHugeMinion, this);
      this.buyBigMinion = bind(this.buyBigMinion, this);
      this.buySmallMinion = bind(this.buySmallMinion, this);
      this.buyMinion = bind(this.buyMinion, this);
      this.maxNumberToBuy = bind(this.maxNumberToBuy, this);
      this.monstersActive = bind(this.monstersActive, this);
      this.availablePopulation = bind(this.availablePopulation, this);
      this.emptyRooms = bind(this.emptyRooms, this);
      this.maxPopulation = bind(this.maxPopulation, this);
      this.totalPopulation = bind(this.totalPopulation, this);
      this.roomCost = bind(this.roomCost, this);
      this.hidePopup = bind(this.hidePopup, this);
      this.displayPopup = bind(this.displayPopup, this);
      this.unitCode = bind(this.unitCode, this);
      this.acolyteUpgradeETA = bind(this.acolyteUpgradeETA, this);
      this.minionUpgradeETA = bind(this.minionUpgradeETA, this);
      this.hugeUnitETA = bind(this.hugeUnitETA, this);
      this.bigUnitETA = bind(this.bigUnitETA, this);
      this.smallUnitETA = bind(this.smallUnitETA, this);
      this.unitETA = bind(this.unitETA, this);
      this.roomETA = bind(this.roomETA, this);
      this.upgradeAcolytesText = bind(this.upgradeAcolytesText, this);
      this.upgradeMinionsText = bind(this.upgradeMinionsText, this);
      this.updateRoomBox = bind(this.updateRoomBox, this);
      this.acolyteUpgradeProgressPercent = bind(this.acolyteUpgradeProgressPercent, this);
      this.minionUpgradeProgressPercent = bind(this.minionUpgradeProgressPercent, this);
      this.hugeUnitProgressPercent = bind(this.hugeUnitProgressPercent, this);
      this.bigUnitProgressPercent = bind(this.bigUnitProgressPercent, this);
      this.smallUnitProgressPercent = bind(this.smallUnitProgressPercent, this);
      this.unitProgressPercent = bind(this.unitProgressPercent, this);
      this.roomProgressPercent = bind(this.roomProgressPercent, this);
      this.reputationRate = bind(this.reputationRate, this);
      this.updateValuesNoApply = bind(this.updateValuesNoApply, this);
      this.updateValues = bind(this.updateValues, this);
      this.minionTick = bind(this.minionTick, this);
      this.acolyteTick = bind(this.acolyteTick, this);
      this.megaTick = bind(this.megaTick, this);
      this.tick = bind(this.tick, this);
      this.catchUp = bind(this.catchUp, this);
      var i, k, l, m, n, o, p, q, ref, ref1, ref2, ref3, ref4, ref5;
      window.simulator = this;
      window.rootScope = $rootScope;
      this.data = new DungeonData();
      this.data.dragMode = false;
      this.data.dragRoom = null;
      this.data.dropRoom = null;
      this.data.dragBox = null;
      this.data.dragText = null;
      this.data.minions = 0;
      this.data.smallMinions = 5;
      this.data.bigMinions = 0;
      this.data.hugeMinions = 0;
      this.data.minionObjects = [];
      for (i = k = 0, ref = this.data.smallMinions - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.data.minionObjects[i] = new SmallMinion();
      }
      this.data.monsters = 0;
      this.data.smallMonsters = 5;
      this.data.bigMonsters = 0;
      this.data.hugeMonsters = 0;
      this.data.monsterObjects = [];
      for (i = l = 0, ref1 = this.data.smallMonsters - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
        this.data.monsterObjects[i] = new SmallMonster();
      }
      this.data.acolytes = 0;
      this.data.smallAcolytes = 5;
      this.data.bigAcolytes = 0;
      this.data.hugeAcolytes = 0;
      this.data.acolyteObjects = [];
      for (i = m = 0, ref2 = this.data.smallAcolytes - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
        this.data.acolyteObjects[i] = new SmallAcolyte();
      }
      this.data.treasure = 10;
      $(document).ready(function() {
        return CanvasInitializer.initCanvas();
      });
      this.data.roomProgress = 0;
      this.data.rooms = 5;
      this.data.roomObjects = [];
      this.data.roomObjects[0] = new Room();
      this.data.roomObjects[0].population = 5;
      this.data.roomObjects[0].size = 10;
      this.data.roomObjects[0].occupantType = unitTypes.smallMinion;
      for (i = n = 0, ref3 = this.data.smallMinions - 1; 0 <= ref3 ? n <= ref3 : n >= ref3; i = 0 <= ref3 ? ++n : --n) {
        this.data.roomObjects[0].minions[i] = this.data.minionObjects[i];
      }
      this.data.roomObjects[1] = new Room();
      this.data.roomObjects[1].population = 5;
      this.data.roomObjects[1].size = 10;
      this.data.roomObjects[1].occupantType = unitTypes.smallMonster;
      this.data.roomObjects[1].population = 5;
      for (i = o = 0, ref4 = this.data.smallMonsters - 1; 0 <= ref4 ? o <= ref4 : o >= ref4; i = 0 <= ref4 ? ++o : --o) {
        this.data.roomObjects[1].monsters[i] = this.data.monsterObjects[i];
      }
      this.data.roomObjects[2] = new Room();
      this.data.roomObjects[2].occupantType = unitTypes.smallAcolyte;
      this.data.roomObjects[2].population = 5;
      this.data.roomObjects[2].size = 10;
      for (i = p = 0, ref5 = this.data.smallAcolytes - 1; 0 <= ref5 ? p <= ref5 : p >= ref5; i = 0 <= ref5 ? ++p : --p) {
        this.data.roomObjects[2].acolytes[i] = this.data.acolyteObjects[i];
      }
      this.data.roomObjects[3] = new Room();
      this.data.roomObjects[4] = new Room();
      this.data.map = new Map();
      this.data.roomObjects[0].boundaries = this.data.map.initialRoomBoundaries;
      for (i = q = 1; q <= 4; i = ++q) {
        this.data.roomObjects[i].boundaries = this.digRoom();
      }
      this.formRoomConnections();
      this.data.adventurers = 0;
      this.data.reputation = 0;
      this.data.devMultiplier = 1;
      this.data.minionMultiplier = 1;
      this.data.acolyteMultiplier = 1;
      this.data.minionUpgradeCost = Math.floor(15000 * 0.2);
      this.data.acolyteUpgradeCost = Math.floor(15000 * 0.2);
      this.data.cost = 4000;
      this.data.lastTickTime = moment().valueOf();
      this.data.firstTick = true;
      this.tickCount = 0;
      setInterval(this.catchUp, 100);
    }

    Dungeon.prototype.catchUp = function() {
      var calc, i, k, newTickTime, ref;
      newTickTime = moment().valueOf();
      calc = Math.floor((newTickTime - this.data.lastTickTime) / 100);
      if (calc > 0) {
        for (i = k = 1, ref = calc; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.tick();
        }
      }
      return this.data.lastTickTime = this.data.lastTickTime + (calc * 100);
    };

    Dungeon.prototype.tick = function() {
      var acolyte, i, k, l, len, len1, len2, m, minion, monster, n, o, p, ref, ref1, ref2, ref3, ref4, ref5;
      this.tickCount += 1;
      ref = this.data.minionObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        minion = ref[k];
        for (i = l = 0, ref1 = this.data.devMultiplier - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
          this.minionTick(minion);
        }
      }
      ref2 = this.data.acolyteObjects;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        acolyte = ref2[m];
        for (i = n = 0, ref3 = this.data.devMultiplier - 1; 0 <= ref3 ? n <= ref3 : n >= ref3; i = 0 <= ref3 ? ++n : --n) {
          this.acolyteTick(acolyte);
        }
      }
      this.updateValues();
      this.updateRoomBox();
      ref4 = this.data.monsterObjects;
      for (o = 0, len2 = ref4.length; o < len2; o++) {
        monster = ref4[o];
        for (i = p = 0, ref5 = this.data.devMultiplier - 1; 0 <= ref5 ? p <= ref5 : p >= ref5; i = 0 <= ref5 ? ++p : --p) {
          monster.tick();
        }
      }
      if (this.data.firstTick) {
        this.updateRoomCanvas();
        this.data.firstTick = false;
      }
      if (this.tickCount === 600) {
        this.tickCount = 0;
        return this.megaTick();
      }
    };

    Dungeon.prototype.megaTick = function() {
      return window.rootScope.save();
    };

    Dungeon.prototype.acolyteTick = function(acolyte) {
      if (acolyte.health < acolyte.maxHealth) {
        acolyte.health += 1;
      }
      if (acolyte.health >= acolyte.maxHealth) {
        return this.data.reputation += acolyte.reputation * this.data.devMultiplier * this.data.acolyteMultiplier;
      }
    };

    Dungeon.prototype.minionTick = function(minion) {
      if (minion.health < minion.maxHealth) {
        minion.health += 1;
      }
      if (minion.health >= minion.maxHealth) {
        return this.data.roomProgress += minion.labor * this.data.devMultiplier * this.data.minionMultiplier;
      }
    };

    Dungeon.prototype.updateValues = function() {
      var adventurerRoll, i, k, ref;
      if (this.data.roomProgress >= this.roomCost()) {
        this.data.roomProgress -= this.roomCost();
        this.data.rooms += 1;
        this.data.roomObjects[this.data.rooms - 1] = new Room();
        this.data.roomObjects[this.data.rooms - 1].boundaries = this.digRoom();
        this.formRoomConnections();
        this.updateRoomCanvas();
      }
      for (i = k = 0, ref = Math.floor(this.data.treasure * this.data.devMultiplier) - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        adventurerRoll = Math.floor((Math.random() * 14500) + 1);
        if (adventurerRoll === 14500) {
          this.runDungeon();
        }
      }
      return window.rootScope.$apply();
    };

    Dungeon.prototype.updateValuesNoApply = function() {
      var adventurerRoll, i, k, ref, results1;
      if (this.data.roomProgress >= this.roomCost()) {
        this.data.roomProgress -= this.roomCost();
        this.data.rooms += 1;
        this.data.roomObjects[this.data.rooms - 1] = new Room();
        this.data.roomObjects[this.data.rooms - 1].boundaries = this.digRoom();
        this.formRoomConnections();
        this.updateRoomCanvas();
      }
      results1 = [];
      for (i = k = 0, ref = Math.floor(this.data.treasure * this.data.devMultiplier) - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        adventurerRoll = Math.floor((Math.random() * 14500) + 1);
        if (adventurerRoll === 14500) {
          results1.push(this.runDungeon());
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    };

    Dungeon.prototype.reputationRate = function() {
      return Math.floor(((this.data.smallAcolytes * 10) + (this.data.acolytes * 160) + (this.data.bigAcolytes * 2560) + (this.data.hugeAcolytes * 40960)) * this.data.acolyteMultiplier);
    };

    Dungeon.prototype.roomProgressPercent = function() {
      return (this.data.roomProgress / this.roomCost() * 100).toString();
    };

    Dungeon.prototype.unitProgressPercent = function() {
      if (this.data.reputation >= this.data.cost) {
        return '100';
      }
      return ((this.data.reputation % this.data.cost) / this.data.cost * 100).toString();
    };

    Dungeon.prototype.smallUnitProgressPercent = function() {
      if (this.data.reputation >= Math.floor(this.data.cost * 0.09375)) {
        return '100';
      }
      return ((this.data.reputation % Math.floor(this.data.cost * 0.09375)) / Math.floor(this.data.cost * 0.09375) * 100).toString();
    };

    Dungeon.prototype.bigUnitProgressPercent = function() {
      if (this.data.reputation >= Math.floor(this.data.cost * 119.42)) {
        return '100';
      }
      return ((this.data.reputation % Math.floor(this.data.cost * 119.42)) / Math.floor(this.data.cost * 119.42) * 100).toString();
    };

    Dungeon.prototype.hugeUnitProgressPercent = function() {
      if (this.data.reputation >= Math.floor(this.data.cost * 17752.88)) {
        return '100';
      }
      return ((this.data.reputation % Math.floor(this.data.cost * 17752.88)) / Math.floor(this.data.cost * 17752.88) * 100).toString();
    };

    Dungeon.prototype.minionUpgradeProgressPercent = function() {
      if (this.data.reputation >= this.data.minionUpgradeCost) {
        return '100';
      }
      return (this.data.reputation / this.data.minionUpgradeCost * 100).toString();
    };

    Dungeon.prototype.acolyteUpgradeProgressPercent = function() {
      if (this.data.reputation >= this.data.acolyteUpgradeCost) {
        return '100';
      }
      return (this.data.reputation / this.data.acolyteUpgradeCost * 100).toString();
    };

    Dungeon.prototype.updateRoomBox = function() {
      var i, k, ref, room, text;
      text = "Room Summary:<br><br>";
      for (i = k = 0, ref = this.data.rooms - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        room = this.data.roomObjects[i];
        text += "Room " + (i + 1).toString() + ":<br>Contains ";
        if (room.occupantType === unitTypes.none) {
          text += "nothing";
        } else if (room.occupantType === unitTypes.minion) {
          text += "minions";
        } else if (room.occupantType === unitTypes.smallMinion) {
          text += "mini-ons";
        } else if (room.occupantType === unitTypes.bigMinion) {
          text += "big minions";
        } else if (room.occupantType === unitTypes.hugeMinion) {
          text += "huge minion";
        } else if (room.occupantType === unitTypes.monster) {
          text += "monsters";
        } else if (room.occupantType === unitTypes.smallMonster) {
          text += "small monsters";
        } else if (room.occupantType === unitTypes.bigMonster) {
          text += "big monsters";
        } else if (room.occupantType === unitTypes.hugeMonster) {
          text += "huge monster";
        } else if (room.occupantType === unitTypes.acolyte) {
          text += "acolytes";
        } else if (room.occupantType === unitTypes.smallAcolyte) {
          text += "small acolytes";
        } else if (room.occupantType === unitTypes.bigAcolyte) {
          text += "big acolytes";
        } else if (room.occupantType === unitTypes.hugeAcolyte) {
          text += "huge acolyte";
        }
        text += ".<br>Population: " + room.population.toString() + "/" + room.size.toString() + "<br><br>";
      }
      return document.getElementById('roomsPanel').innerHTML = text;
    };

    Dungeon.prototype.upgradeMinionsText = function() {
      return "Upgrade Minions (" + this.data.minionUpgradeCost + " reputation)";
    };

    Dungeon.prototype.upgradeAcolytesText = function() {
      return "Upgrade Acolytes (" + this.data.acolyteUpgradeCost + " reputation)";
    };

    Dungeon.prototype.roomETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = this.roomCost() - this.data.roomProgress;
      rate = (this.data.smallMinions + (this.data.minions * 16) + (this.data.bigMinions * 256) + (this.data.hugeMinions * 4096)) * this.data.devMultiplier * this.data.minionMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.unitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > this.data.cost) {
        remaining = 0;
      } else {
        remaining = this.data.cost - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.smallUnitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > Math.floor(this.data.cost * 0.09375)) {
        remaining = 0;
      } else {
        remaining = Math.floor(this.data.cost * 0.09375) - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.bigUnitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > Math.floor(this.data.cost * 119.42)) {
        remaining = 0;
      } else {
        remaining = Math.floor(this.data.cost * 119.42) - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.hugeUnitETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > Math.floor(this.data.cost * 17752.88)) {
        remaining = 0;
      } else {
        remaining = Math.floor(this.data.cost * 17752.88) - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.minionUpgradeETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > this.data.minionUpgradeCost) {
        remaining = 0;
      } else {
        remaining = this.data.minionUpgradeCost - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.acolyteUpgradeETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      if (this.data.reputation > this.data.acolyteUpgradeCost) {
        remaining = 0;
      } else {
        remaining = this.data.acolyteUpgradeCost - this.data.reputation;
      }
      rate = (this.data.smallAcolytes + (this.data.acolytes * 16) + (this.data.bigAcolytes * 256) + (this.data.hugeAcolytes * 4096)) * this.data.devMultiplier * this.data.acolyteMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + "y";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + "M";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + "d";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + "h";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + "m";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + "s";
      }
      return specific;
    };

    Dungeon.prototype.updateProgressBar = function(bar, percent) {
      return bar.width(percent + "%");
    };

    Dungeon.prototype.updateRoomCanvas = function() {
      var color, i, j, k, l, m, ref, ref1, ref2, ref3, room, unitRepresentation;
      console.log('updating');
      window.canvas.clear();
      window.canvas.setBackgroundColor('gray');
      for (i = k = 0, ref = this.data.map.sizeX - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        for (j = l = 0, ref1 = this.data.map.sizeY - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
          if (this.data.map.tiles[i][j] === ' ') {
            window.canvas.add(new fabric.Rect({
              left: i * 12,
              top: j * 12,
              height: 12,
              width: 12,
              stroke: 'black',
              fill: 'black',
              strokeWidth: 1,
              selectable: false
            }));
          }
        }
      }
      for (i = m = 0, ref2 = this.data.roomObjects.length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
        room = this.data.roomObjects[i];
        window.canvas.add(new fabric.Text((i + 1).toString(), {
          left: (room.boundaries[0] * 12) + 30,
          top: (room.boundaries[1] * 12) + 30,
          originX: 'center',
          originY: 'center',
          fill: 'white',
          fontSize: 16,
          selectable: false
        }));
        ref3 = this.unitCode(this.data.roomObjects[i]), unitRepresentation = ref3[0], color = ref3[1];
        window.canvas.add(new fabric.Text(unitRepresentation, {
          left: room.boundaries[0] * 12,
          top: room.boundaries[1] * 12,
          originX: 'left',
          originY: 'top',
          fill: color,
          fontWeight: 'bold',
          fontSize: 16,
          selectable: false
        }));
      }
      window.canvas.off;
      window.canvas.on('mouse:move', function(options) {
        return window.simulator.roomMouseOver(options);
      });
      window.canvas.on('mouse:down', function(options) {
        return window.simulator.roomMouseDown(options);
      });
      window.canvas.on('mouse:up', function(options) {
        return window.simulator.roomMouseUp(options);
      });
      return window.canvas.renderAll();
    };

    Dungeon.prototype.unitCode = function(room) {
      var color, occupants, text;
      occupants = room.occupantType;
      if (occupants === unitTypes.smallMinion || occupants === unitTypes.minion || occupants === unitTypes.bigMinion || occupants === unitTypes.hugeMinion) {
        text = 'Mi';
        color = 'yellow';
      } else if (occupants === unitTypes.smallMonster || occupants === unitTypes.monster || occupants === unitTypes.bigMonster || occupants === unitTypes.hugeMonster) {
        text = 'Mo';
        color = 'red';
      } else if (occupants === unitTypes.smallAcolyte || occupants === unitTypes.acolyte || occupants === unitTypes.bigAcolyte || occupants === unitTypes.hugeAcolyte) {
        text = 'A';
        color = 'cyan';
      }
      if (occupants === unitTypes.smallMinion || occupants === unitTypes.smallMonster || occupants === unitTypes.smallAcolyte) {
        text += '1';
      } else if (occupants === unitTypes.minion || occupants === unitTypes.monster || occupants === unitTypes.acolyte) {
        text += '2';
      } else if (occupants === unitTypes.bigMinion || occupants === unitTypes.bigMonster || occupants === unitTypes.bigAcolyte) {
        text = +'3';
      } else if (occupants === unitTypes.hugeMinion || occupants === unitTypes.hugeMonster || occupants === unitTypes.hugeAcolyte) {
        text = +'3';
      }
      text += ' x';
      text += room.population.toString();
      return [text, color];
    };

    Dungeon.prototype.roomMouseOver = function(options) {
      var boundaries, color, i, k, ref, ref1, room, unitRepresentation, x, y;
      x = options.e.layerX;
      y = options.e.layerY;
      if (this.data.dragMode) {
        if (this.data.dragBox !== null) {
          window.canvas.remove(this.data.dragBox);
        }
        if (this.data.dragText !== null) {
          window.canvas.remove(this.data.dragText);
        }
        this.data.dragBox = new fabric.Rect({
          left: x,
          top: y,
          height: 60,
          width: 60,
          stroke: 'black',
          fill: 'black',
          strokeWidth: 1,
          selectable: false
        });
        room = this.data.roomObjects[this.data.dragRoom];
        ref = this.unitCode(room), unitRepresentation = ref[0], color = ref[1];
        this.data.dragText = new fabric.Text(unitRepresentation, {
          left: x,
          top: y,
          originX: 'left',
          originY: 'top',
          fill: color,
          fontWeight: 'bold',
          fontSize: 16,
          selectable: false
        });
        window.canvas.add(this.data.dragBox);
        window.canvas.add(this.data.dragText);
        window.canvas.renderAll();
        this.hidePopup();
        return;
      }
      for (i = k = 0, ref1 = this.data.roomObjects.length - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
        room = this.data.roomObjects[i];
        boundaries = room.boundaries;
        if (x >= boundaries[0] * 12 && x <= (boundaries[2] + 1) * 12 && y >= boundaries[1] * 12 && y <= (boundaries[3] + 1) * 12) {
          this.displayPopup(i, options.e.x, options.e.y);
          return;
        }
      }
      this.hidePopup();
    };

    Dungeon.prototype.roomMouseDown = function(options) {
      var boundaries, i, k, ref, room, x, y;
      this.data.dragMode = true;
      x = options.e.layerX;
      y = options.e.layerY;
      for (i = k = 0, ref = this.data.roomObjects.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        room = this.data.roomObjects[i];
        boundaries = room.boundaries;
        if (x >= boundaries[0] * 12 && x <= (boundaries[2] + 1) * 12 && y >= boundaries[1] * 12 && y <= (boundaries[3] + 1) * 12) {
          this.data.dragRoom = i;
          return;
        }
      }
    };

    Dungeon.prototype.roomMouseUp = function(options) {
      var boundaries, i, k, ref, room, swapMonsters, swapOccupantType, swapPopulation, swapSize, x, y;
      if (this.data.dragMode === false) {
        return;
      }
      this.data.dragMode = false;
      x = options.e.layerX;
      y = options.e.layerY;
      for (i = k = 0, ref = this.data.roomObjects.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        room = this.data.roomObjects[i];
        boundaries = room.boundaries;
        if (x >= boundaries[0] * 12 && x <= (boundaries[2] + 1) * 12 && y >= boundaries[1] * 12 && y <= (boundaries[3] + 1) * 12) {
          this.data.dropRoom = i;
          if (this.data.dragRoom !== null) {
            swapPopulation = this.data.roomObjects[this.data.dragRoom].population;
            swapSize = this.data.roomObjects[this.data.dragRoom].size;
            swapOccupantType = this.data.roomObjects[this.data.dragRoom].occupantType;
            swapMonsters = this.data.roomObjects[this.data.dragRoom].monsters;
            this.data.roomObjects[this.data.dragRoom].population = this.data.roomObjects[this.data.dropRoom].population;
            this.data.roomObjects[this.data.dragRoom].size = this.data.roomObjects[this.data.dropRoom].size;
            this.data.roomObjects[this.data.dragRoom].occupantType = this.data.roomObjects[this.data.dropRoom].occupantType;
            this.data.roomObjects[this.data.dragRoom].monsters = this.data.roomObjects[this.data.dropRoom].monsters;
            this.data.roomObjects[this.data.dropRoom].population = swapPopulation;
            this.data.roomObjects[this.data.dropRoom].size = swapSize;
            this.data.roomObjects[this.data.dropRoom].occupantType = swapOccupantType;
            this.data.roomObjects[this.data.dropRoom].monsters = swapMonsters;
            this.updateRoomCanvas();
          }
          return;
        }
      }
      this.data.dragRoom = null;
      return this.data.dropRoom = null;
    };

    Dungeon.prototype.displayPopup = function(roomIndex, x, y) {
      var div, room, text;
      div = $('#roomTooltip');
      div.css({
        left: x + 20,
        top: y - 20,
        visibility: 'visible'
      });
      room = this.data.roomObjects[roomIndex];
      text = "Room " + (roomIndex + 1).toString() + ":";
      if (roomIndex === 0) {
        text += '<br><span style="color: blue;">Dungeon Entrance</span>';
      }
      text += "<br>Contains ";
      if (room.occupantType === unitTypes.none) {
        text += "nothing";
      } else if (room.occupantType === unitTypes.minion) {
        text += "minions";
      } else if (room.occupantType === unitTypes.smallMinion) {
        text += "mini-ons";
      } else if (room.occupantType === unitTypes.bigMinion) {
        text += "big minions";
      } else if (room.occupantType === unitTypes.hugeMinion) {
        text += "huge minion";
      } else if (room.occupantType === unitTypes.monster) {
        text += "monsters";
      } else if (room.occupantType === unitTypes.smallMonster) {
        text += "small monsters";
      } else if (room.occupantType === unitTypes.bigMonster) {
        text += "big monsters";
      } else if (room.occupantType === unitTypes.hugeMonster) {
        text += "huge monster";
      } else if (room.occupantType === unitTypes.acolyte) {
        text += "acolytes";
      } else if (room.occupantType === unitTypes.smallAcolyte) {
        text += "small acolytes";
      } else if (room.occupantType === unitTypes.bigAcolyte) {
        text += "big acolytes";
      } else if (room.occupantType === unitTypes.hugeAcolyte) {
        text += "huge acolyte";
      }
      text += ".<br>Population: " + room.population.toString() + "/" + room.size.toString() + "<br><br>";
      div.html(text);
    };

    Dungeon.prototype.hidePopup = function() {
      var div;
      div = $('#roomTooltip');
      div.css({
        visibility: 'hidden'
      });
    };

    Dungeon.prototype.roomCost = function() {
      var costToBuild;
      costToBuild = 14528;
      if (this.data.rooms >= 100) {
        costToBuild = 8366815749600 * 8;
      } else if (this.data.rooms >= 30) {
        costToBuild = 39841974900 * 8;
      } else if (this.data.rooms >= 25) {
        costToBuild = 79963200 * 8;
      } else if (this.data.rooms >= 20) {
        costToBuild = 3719216 * 8;
      } else if (this.data.rooms >= 15) {
        costToBuild = 929804;
      } else if (this.data.rooms >= 10) {
        costToBuild = 232451;
      }
      return costToBuild;
    };

    Dungeon.prototype.totalPopulation = function() {
      var bigUnits, hugeUnits, normalUnits, smallUnits;
      smallUnits = this.data.smallMinions + this.data.smallMonsters + this.data.smallAcolytes;
      normalUnits = this.data.minions + this.data.monsters + this.data.acolytes;
      bigUnits = this.data.bigMinions + this.data.bigMonsters + this.data.bigAcolytes;
      hugeUnits = this.data.hugeMinions + this.data.hugeMonsters + this.data.hugeAcolytes;
      return (smallUnits * 5) + (normalUnits * 10) + (bigUnits * 25) + (hugeUnits * 50);
    };

    Dungeon.prototype.maxPopulation = function() {
      return this.data.rooms * 50;
    };

    Dungeon.prototype.emptyRooms = function() {
      var count, k, len, ref, room;
      count = 0;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.population === 0) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.availablePopulation = function() {
      return Math.max(this.maxPopulation() - this.totalPopulation(), 0);
    };

    Dungeon.prototype.monstersActive = function() {
      var count, k, len, monster, ref;
      count = 0;
      ref = this.data.monsterObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.maxNumberToBuy = function(type) {
      var cost, k, len, max, maxBasedOnCost, maxBasedOnRooms, ref, room;
      if (type === unitTypes.minion || type === unitTypes.monster || type === unitTypes.acolyte) {
        cost = this.data.cost;
        max = 5;
      } else if (type === unitTypes.smallMinion || type === unitTypes.smallMonster || type === unitTypes.smallAcolyte) {
        cost = this.data.cost * 0.09375;
        max = 10;
      } else if (type === unitTypes.bigMinion || type === unitTypes.bigMonster || type === unitTypes.bigAcolyte) {
        cost = this.data.cost * 119.42;
        max = 2;
      } else if (type === unitTypes.hugeMinion || type === unitTypes.hugeMonster || type === unitTypes.hugeAcolyte) {
        cost = this.data.cost * 17752.88;
        max = 1;
      }
      maxBasedOnCost = Math.floor(this.data.reputation / cost);
      maxBasedOnRooms = 0;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === type) {
          maxBasedOnRooms += max - room.population;
        } else if (room.occupantType === unitTypes.none) {
          maxBasedOnRooms += max;
        }
      }
      return Math.min(maxBasedOnCost, maxBasedOnRooms);
    };

    Dungeon.prototype.buyMinion = function() {
      if (this.data.reputation > this.data.cost) {
        if (this.allocateRoom(unitTypes.minion)) {
          this.data.minions += 1;
          this.data.reputation -= this.data.cost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buySmallMinion = function() {
      var smallCost;
      smallCost = Math.floor(this.data.cost * 0.09375);
      if (this.data.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMinion)) {
          this.data.smallMinions += 1;
          this.data.reputation -= smallCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyBigMinion = function() {
      var bigCost;
      bigCost = Math.floor(this.data.cost * 119.42);
      if (this.data.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMinion)) {
          this.data.bigMinions += 1;
          this.data.reputation -= bigCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyHugeMinion = function() {
      var hugeCost;
      hugeCost = Math.floor(this.data.cost * 17752.88);
      if (this.data.reputation > hugeCost) {
        if (this.allocateRoom(unitTypes.hugeMinion)) {
          this.data.hugeMinions += 1;
          this.data.reputation -= hugeCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyMonster = function() {
      if (this.data.reputation > this.data.cost) {
        if (this.allocateRoom(unitTypes.monster)) {
          this.data.reputation -= this.data.cost;
          this.data.monsters += 1;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buySmallMonster = function() {
      var smallCost;
      smallCost = Math.floor(this.data.cost * 0.09375);
      if (this.data.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMonster)) {
          this.data.smallMonsters += 1;
          this.data.reputation -= smallCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyBigMonster = function() {
      var bigCost;
      bigCost = Math.floor(this.data.cost * 119.42);
      if (this.data.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMonster)) {
          this.data.bigMonsters += 1;
          this.data.reputation -= bigCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyHugeMonster = function() {
      var hugeCost;
      hugeCost = Math.floor(this.data.cost * 17752.88);
      if (this.data.reputation > hugeCost) {
        if (this.allocateRoom(unitTypes.hugeMonster)) {
          this.data.hugeMonsters += 1;
          this.data.reputation -= hugeCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyAcolyte = function() {
      if (this.data.reputation > this.data.cost) {
        if (this.allocateRoom(unitTypes.acolyte)) {
          this.data.reputation -= this.data.cost;
          this.data.acolytes += 1;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buySmallAcolyte = function() {
      var smallCost;
      smallCost = Math.floor(this.data.cost * 0.09375);
      if (this.data.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallAcolyte)) {
          this.data.smallAcolytes += 1;
          this.data.reputation -= smallCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyBigAcolyte = function() {
      var bigCost;
      bigCost = Math.floor(this.data.cost * 119.42);
      if (this.data.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigAcolyte)) {
          this.data.bigAcolytes += 1;
          this.data.reputation -= bigCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyHugeAcolyte = function() {
      var hugeCost;
      hugeCost = Math.floor(this.data.cost * 17752.88);
      if (this.data.reputation > hugeCost) {
        if (this.allocateRoom(unitTypes.hugeAcolyte)) {
          this.data.hugeAcolytes += 1;
          this.data.reputation -= hugeCost;
          return this.updateRoomCanvas();
        }
      }
    };

    Dungeon.prototype.buyAllMinions = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.minion);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyMinion();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllSmallMinions = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.smallMinion);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buySmallMinion();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllBigMinions = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.bigMinion);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyBigMinion();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllHugeMinions = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.hugeMinion);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyHugeMinion();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllMonsters = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.monster);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyMonster();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllSmallMonsters = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.smallMonster);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buySmallMonster();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllBigMonsters = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.bigMonster);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyBigMonster();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllHugeMonsters = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.hugeMonster);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyHugeMonster();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllAcolytes = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.acolyte);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyAcolyte();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllSmallAcolytes = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.smallAcolyte);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buySmallAcolyte();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllBigAcolytes = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.bigAcolyte);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyBigAcolyte();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyAllHugeAcolytes = function() {
      var i, k, number, ref;
      number = this.maxNumberToBuy(unitTypes.hugeAcolyte);
      for (i = k = 0, ref = number - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.buyHugeAcolyte();
      }
      return this.updateRoomCanvas();
    };

    Dungeon.prototype.buyRoomOfSmallMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.smallMinion, 10);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buySmallMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.minion, 5);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfBigMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.bigMinion, 2);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyBigMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfSmallMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.smallMonster, 10);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buySmallMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.monster, 5);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfBigMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.bigMonster, 2);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyBigMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfSmallAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.smallAcolyte, 10);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buySmallAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.acolyte, 5);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.buyRoomOfBigAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForBuyAll(unitTypes.bigAcolyte, 2);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.buyBigAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfSmallMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.smallMinion);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellSmallMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.minion);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfBigMinions = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.bigMinion);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellBigMinion();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfSmallMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.smallMonster);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellSmallMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.monster);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfBigMonsters = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.bigMonster);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellBigMonster();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfSmallAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.smallAcolyte);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellSmallAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.acolyte);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.sellRoomOfBigAcolytes = function() {
      var i, k, number, ref;
      number = this.calculateRoomCapacityForSellAll(unitTypes.bigAcolyte);
      if (number > 0) {
        for (i = k = 1, ref = number; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          this.sellBigAcolyte();
        }
        return this.updateRoomCanvas();
      }
    };

    Dungeon.prototype.calculateRoomCapacityForBuyAll = function(unitType, max) {
      var k, len, newPotentialNumber, number, ref, room;
      number = max + 1;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === unitType && room.population < max) {
          newPotentialNumber = max - room.population;
        } else if (room.occupantType === unitTypes.none) {
          newPotentialNumber = max;
        }
        if (newPotentialNumber < number) {
          number = newPotentialNumber;
        }
      }
      if (number === max + 1) {
        return 0;
      } else {
        return number;
      }
    };

    Dungeon.prototype.calculateRoomCapacityForSellAll = function(unitType) {
      var k, len, newPotentialNumber, number, ref, room;
      number = 999;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === unitType && room.population !== 0) {
          newPotentialNumber = room.population;
        }
        if (newPotentialNumber < number) {
          number = newPotentialNumber;
        }
      }
      if (number === 999) {
        return 0;
      } else {
        return number;
      }
    };

    Dungeon.prototype.sellMinion = function() {
      if (this.data.minions + this.data.smallMinions + this.data.bigMinions + this.data.hugeMinions > 1) {
        this.data.minions -= 1;
        return this.optimizeRemoval(unitTypes.minion);
      }
    };

    Dungeon.prototype.sellSmallMinion = function() {
      if (this.data.minions + this.data.smallMinions + this.data.bigMinions + this.data.hugeMinions > 1) {
        this.data.smallMinions -= 1;
        return this.optimizeRemoval(unitTypes.smallMinion);
      }
    };

    Dungeon.prototype.sellBigMinion = function() {
      if (this.data.minions + this.data.smallMinions + this.data.bigMinions + this.data.hugeMinions > 1) {
        this.data.bigMinions -= 1;
        return this.optimizeRemoval(unitTypes.bigMinion);
      }
    };

    Dungeon.prototype.sellHugeMinion = function() {
      if (this.data.minions + this.data.smallMinions + this.data.bigMinions + this.data.hugeMinions > 1) {
        this.data.hugeMinions -= 1;
        return this.optimizeRemoval(unitTypes.hugeMinion);
      }
    };

    Dungeon.prototype.sellMonster = function() {
      if (this.data.monsters > 0) {
        this.data.monsters -= 1;
        return this.optimizeRemoval(unitTypes.monster);
      }
    };

    Dungeon.prototype.sellSmallMonster = function() {
      if (this.data.smallMonsters > 0) {
        this.data.smallMonsters -= 1;
        return this.optimizeRemoval(unitTypes.smallMonster);
      }
    };

    Dungeon.prototype.sellBigMonster = function() {
      if (this.data.bigMonsters > 0) {
        this.data.bigMonsters -= 1;
        return this.optimizeRemoval(unitTypes.bigMonster);
      }
    };

    Dungeon.prototype.sellHugeMonster = function() {
      if (this.data.hugeMonsters > 0) {
        this.data.hugeMonsters -= 1;
        return this.optimizeRemoval(unitTypes.hugeMonster);
      }
    };

    Dungeon.prototype.sellAcolyte = function() {
      if (this.data.acolytes + this.data.smallAcolytes + this.data.bigAcolytes + this.data.hugeAcolytes > 1) {
        this.data.acolytes -= 1;
        return this.optimizeRemoval(unitTypes.acolyte);
      }
    };

    Dungeon.prototype.sellSmallAcolyte = function() {
      if (this.data.acolytes + this.data.smallAcolytes + this.data.bigAcolytes + this.data.hugeAcolytes > 1) {
        this.data.smallAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.smallAcolyte);
      }
    };

    Dungeon.prototype.sellBigAcolyte = function() {
      if (this.data.acolytes + this.data.smallAcolytes + this.data.bigAcolytes + this.data.hugeAcolytes > 1) {
        this.data.bigAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.bigAcolyte);
      }
    };

    Dungeon.prototype.sellHugeAcolyte = function() {
      if (this.data.acolytes + this.data.smallAcolytes + this.data.bigAcolytes + this.data.hugeAcolytes > 1) {
        this.data.hugeAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.hugeAcolyte);
      }
    };

    Dungeon.prototype.upgradeMinions = function() {
      if (this.data.reputation >= this.data.minionUpgradeCost) {
        this.data.reputation -= this.data.minionUpgradeCost;
        this.data.minionMultiplier = this.data.minionMultiplier * 1.2;
        return this.data.minionUpgradeCost = Math.floor(this.data.minionUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.upgradeAcolytes = function() {
      if (this.data.reputation >= this.data.acolyteUpgradeCost) {
        this.data.reputation -= this.data.acolyteUpgradeCost;
        this.data.acolyteMultiplier = this.data.acolyteMultiplier * 1.2;
        return this.data.acolyteUpgradeCost = Math.floor(this.data.acolyteUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.optimizeRemoval = function(type) {
      var i, k, l, len, monster, ref, ref1, room, roomSelected;
      roomSelected = null;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType !== type) {
          continue;
        }
        if (roomSelected === null && room.population > 0) {
          roomSelected = room;
        } else if (room.population < roomSelected.population && room.population > 0) {
          roomSelected = room;
        }
      }
      roomSelected.population -= 1;
      if (type === unitTypes.monster || type === unitTypes.smallMonster || type === unitTypes.bigMonster || type === unitTypes.hugeMonster) {
        for (i = l = 0, ref1 = roomSelected.monsters.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
          monster = roomSelected.monsters[i];
          if (monster.type === type) {
            roomSelected.monsters.splice(i, 1);
            break;
          }
        }
      }
      if (roomSelected.population === 0) {
        return roomSelected.occupantType = unitTypes.none;
      }
    };

    Dungeon.prototype.runDungeon = function() {
      var acolyte, adventurer, done, hasTreasure, k, l, len, len1, minion, ref, ref1, room;
      this.narrate('An adventurer arrives!');
      adventurer = new Adventurer();
      done = false;
      room = null;
      hasTreasure = false;
      while (!done) {
        room = this.traverseRooms(room);
        if (room.occupantType === unitTypes.monster || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.bigMonster || room.occupantType === unitTypes.hugeMonster) {
          if (this.encounterMonsters(adventurer, room)) {
            return;
          }
        } else {
          ref = room.acolytes;
          for (k = 0, len = ref.length; k < len; k++) {
            acolyte = ref[k];
            acolyte.health = 0;
          }
          ref1 = room.minions;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            minion = ref1[l];
            minion.health = 0;
          }
        }
        if (room === this.data.roomObjects[this.data.roomObjects.length - 1]) {
          hasTreasure = true;
        }
        if (hasTreasure && room === this.data.roomObjects[0]) {
          done = true;
        }
      }
      if (this.data.treasure > 1) {
        this.data.treasure -= 1;
        return this.narrate('The adventurer has successfully beaten all of your monsters! They take one of your treasures!');
      } else {
        return this.narrate('The adventurer finds nothing and leaves.');
      }
    };

    Dungeon.prototype.traverseRooms = function(room) {
      var connection, k, len, possibleConnections, rand, ref;
      if (room === null) {
        return this.data.roomObjects[0];
      }
      possibleConnections = [];
      ref = this.data.connections;
      for (k = 0, len = ref.length; k < len; k++) {
        connection = ref[k];
        if (room === this.data.roomObjects[connection.room]) {
          possibleConnections.push(connection.room2);
        } else if (room === this.data.roomObjects[connection.room2]) {
          possibleConnections.push(connection.room);
        }
      }
      rand = possibleConnections[Math.floor(Math.random() * possibleConnections.length)];
      return this.data.roomObjects[rand];
    };

    Dungeon.prototype.encounterMonsters = function(adventurer, room) {
      this.doCombat(adventurer, room);
      if (adventurer.hp <= 0) {
        this.defeatAdventurer(room);
        return true;
      } else {
        return false;
      }
    };

    Dungeon.prototype.doCombat = function(adventurer, room) {
      var k, len, monster, ref, results1, turnRoll;
      if (this.anyMonstersActive(room)) {
        turnRoll = Math.floor((Math.random() * 2) + 1);
        results1 = [];
        while (adventurer.hp > 0 && this.anyMonstersActive(room)) {
          if (turnRoll === 1) {
            monster = this.monsterWithLowestHp(room);
            monster.hp -= Math.floor((Math.random() * 8) + 3);
            turnRoll = 2;
            if (monster.hp <= 0) {
              monster.hp = 0;
              monster.health = 0;
              results1.push(this.narrate('One of your monsters has been disabled by an adventurer.'));
            } else {
              results1.push(void 0);
            }
          } else if (turnRoll === 2) {
            ref = room.monsters;
            for (k = 0, len = ref.length; k < len; k++) {
              monster = ref[k];
              adventurer.hp -= Math.max(Math.floor((Math.random() * 12) + 4 + monster.damage), 0);
            }
            results1.push(turnRoll = 1);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
    };

    Dungeon.prototype.anyMonstersActive = function(room) {
      var k, len, monster, ref;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.monsterWithLowestHp = function(room) {
      var k, len, lowestHp, monster, monsterSelected, ref;
      lowestHp = 1000000;
      monsterSelected = null;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.hp < lowestHp && monster.isActive()) {
          lowestHp = monster.hp;
          monsterSelected = monster;
        }
      }
      return monsterSelected;
    };

    Dungeon.prototype.numActiveMonsters = function(room) {
      var count, k, len, monster, ref;
      count = 0;
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.defeatAdventurer = function(room) {
      var k, len, monster, ref, type, xp;
      this.data.adventurers += 1;
      this.data.treasure += 1;
      xp = Math.floor(100 / this.numActiveMonsters(room));
      ref = room.monsters;
      for (k = 0, len = ref.length; k < len; k++) {
        monster = ref[k];
        if (monster.isActive()) {
          monster.xp += xp;
          monster.checkForLevelUp();
        }
      }
      if (room.occupantType === unitTypes.monster) {
        type = "monsters";
      } else if (room.occupantType === unitTypes.smallMonster) {
        type = "small monsters";
      } else if (room.occupantType === unitTypes.bigMonster) {
        type = "big monsters";
      } else if (room.occupantType === unitTypes.hugeMonster) {
        type = "huge monsters";
      }
      return this.narrate('Some of your ' + type + ' have slain the adventurer! You take their treasure!');
    };

    Dungeon.prototype.narrate = function(text) {
      document.getElementById('narrationContainer').innerHTML += '<br>' + text;
      return document.getElementById('narrationContainer').scrollTop = document.getElementById('narrationContainer').scrollHeight;
    };

    Dungeon.prototype.allocateRoom = function(type) {
      var k, len, ref, room;
      ref = this.data.roomObjects;
      for (k = 0, len = ref.length; k < len; k++) {
        room = ref[k];
        if (room.occupantType === unitTypes.none) {
          room.occupantType = type;
          room.population += 1;
          this.addUnitObjectToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        } else if (room.occupantType === type && room.population < room.size) {
          room.population += 1;
          this.addUnitObjectToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.addUnitObjectToRoom = function(room) {
      var acolyte, minion, monster;
      if (room.occupantType === unitTypes.monster || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.bigMonster || room.occupantType === unitTypes.hugeMonster) {
        if (room.occupantType === unitTypes.monster) {
          monster = new Monster();
        } else if (room.occupantType === unitTypes.smallMonster) {
          monster = new SmallMonster();
        } else if (room.occupantType === unitTypes.bigMonster) {
          monster = new BigMonster();
        } else if (room.occupantType === unitTypes.hugeMonster) {
          monster = new HugeMonster();
        }
        this.data.monsterObjects[this.data.monsters + this.data.smallMonsters + this.data.bigMonsters + this.data.hugeMonsters] = monster;
        return room.monsters[room.population - 1] = monster;
      } else if (room.occupantType === unitTypes.minion || room.occupantType === unitTypes.smallMinion || room.occupantType === unitTypes.bigMinion || room.occupantType === unitTypes.hugeMinion) {
        if (room.occupantType === unitTypes.minion) {
          minion = new Minion();
        } else if (room.occupantType === unitTypes.smallMinion) {
          minion = new SmallMinion();
        } else if (room.occupantType === unitTypes.bigMinion) {
          minion = new BigMinion();
        } else if (room.occupantType === unitTypes.hugeMinion) {
          minion = new HugeMinion();
        }
        this.data.minionObjects[this.data.minions + this.data.smallMinions + this.data.bigMinions + this.data.hugeMinions] = minion;
        return room.minions[room.population - 1] = minion;
      } else if (room.occupantType === unitTypes.acolyte || room.occupantType === unitTypes.smallAcolyte || room.occupantType === unitTypes.bigAcolyte || room.occupantType === unitTypes.hugeAcolyte) {
        if (room.occupantType === unitTypes.acolyte) {
          acolyte = new Acolyte();
        } else if (room.occupantType === unitTypes.smallAcolyte) {
          acolyte = new SmallAcolyte();
        } else if (room.occupantType === unitTypes.bigAcolyte) {
          acolyte = new BigAcolyte();
        } else if (room.occupantType === unitTypes.hugeAcolyte) {
          acolyte = new HugeAcolyte();
        }
        this.data.acolyteObjects[this.data.acolytes + this.data.smallAcolytes + this.data.bigAcolytes + this.data.hugeAcolytes] = acolyte;
        return room.acolytes[room.population - 1] = acolyte;
      }
    };

    Dungeon.prototype.adjustMaxPopulation = function(room) {
      if (room.occupantType === unitTypes.smallMinion || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.smallAcolyte) {
        return room.size = 10;
      } else if (room.occupantType === unitTypes.bigMinion || room.occupantType === unitTypes.bigMonster || room.occupantType === unitTypes.bigAcolyte) {
        return room.size = 2;
      } else if (room.occupantType === unitTypes.hugeMinion || room.occupantType === unitTypes.hugeMonster || room.occupantType === unitTypes.hugeAcolyte) {
        return room.size = 1;
      } else {
        return room.size = 5;
      }
    };

    Dungeon.prototype.digRoom = function() {
      var boundaries, facing, ref, ref1, result, x, y;
      result = false;
      while (result === false) {
        ref = this.pickRandomWall(), x = ref[0], y = ref[1], facing = ref[2];
        ref1 = this.data.map.excavate(x, y, facing), result = ref1[0], boundaries = ref1[1];
      }
      return boundaries;
    };

    Dungeon.prototype.pickRandomWall = function() {
      var facing, x, y;
      facing = null;
      while (facing === null) {
        x = Math.floor(Math.random() * (this.data.map.sizeX - (this.data.map.border * 2) - 1)) + this.data.map.border;
        y = Math.floor(Math.random() * (this.data.map.sizeY - (this.data.map.border * 2) - 1)) + this.data.map.border;
        facing = this.checkForEmptySpace(x, y);
      }
      return [x, y, facing];
    };

    Dungeon.prototype.checkForEmptySpace = function(x, y) {
      if (this.data.map.tiles[x][y + 1] === ' ') {
        return 2;
      }
      if (this.data.map.tiles[x - 1][y] === ' ') {
        return 3;
      }
      if (this.data.map.tiles[x][y - 1] === ' ') {
        return 0;
      }
      if (this.data.map.tiles[x + 1][y] === ' ') {
        return 1;
      }
      return null;
    };

    Dungeon.prototype.formRoomConnections = function() {
      var i, j, k, obj, ref, results1, room, room2;
      this.data.connections = [];
      results1 = [];
      for (i = k = 0, ref = this.data.roomObjects.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results1.push((function() {
          var l, ref1, results2;
          results2 = [];
          for (j = l = 0, ref1 = this.data.roomObjects.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            room = this.data.roomObjects[i];
            room2 = this.data.roomObjects[j];
            if (this.roomsConnected(room, room2)) {
              obj = new RoomConnection;
              obj.room = i;
              obj.room2 = j;
              if (!this.checkIfConnectionExists(obj)) {
                results2.push(this.data.connections.push(obj));
              } else {
                results2.push(void 0);
              }
            } else {
              results2.push(void 0);
            }
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    Dungeon.prototype.roomsConnected = function(room, room2) {
      var doorLocations;
      if (room === room2) {
        return false;
      }
      if (!this.roomsAdjacent(room, room2)) {
        return false;
      }
      doorLocations = this.findDoors(room);
      if (this.checkDoorAdjacency(doorLocations, room2)) {
        return true;
      }
      return false;
    };

    Dungeon.prototype.findDoors = function(room) {
      var k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, x, y;
      results = [];
      x = room.boundaries[0] - 1;
      for (y = k = ref = room.boundaries[1], ref1 = room.boundaries[3]; ref <= ref1 ? k <= ref1 : k >= ref1; y = ref <= ref1 ? ++k : --k) {
        if (this.data.map.tiles[x][y] === ' ') {
          results.push([x, y]);
        }
      }
      x = room.boundaries[2] + 1;
      for (y = l = ref2 = room.boundaries[1], ref3 = room.boundaries[3]; ref2 <= ref3 ? l <= ref3 : l >= ref3; y = ref2 <= ref3 ? ++l : --l) {
        if (this.data.map.tiles[x][y] === ' ') {
          results.push([x, y]);
        }
      }
      y = room.boundaries[1] - 1;
      for (x = m = ref4 = room.boundaries[0], ref5 = room.boundaries[2]; ref4 <= ref5 ? m <= ref5 : m >= ref5; x = ref4 <= ref5 ? ++m : --m) {
        if (this.data.map.tiles[x][y] === ' ') {
          results.push([x, y]);
        }
      }
      y = room.boundaries[3] + 1;
      for (x = n = ref6 = room.boundaries[0], ref7 = room.boundaries[2]; ref6 <= ref7 ? n <= ref7 : n >= ref7; x = ref6 <= ref7 ? ++n : --n) {
        if (this.data.map.tiles[x][y] === ' ') {
          results.push([x, y]);
        }
      }
      return results;
    };

    Dungeon.prototype.checkDoorAdjacency = function(doorLocations, room2) {
      var coords, k, l, len, m, n, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, x, x2, y, y2;
      for (k = 0, len = doorLocations.length; k < len; k++) {
        coords = doorLocations[k];
        x = coords[0], y = coords[1];
        x2 = room2.boundaries[0] - 1;
        for (y2 = l = ref = room2.boundaries[1], ref1 = room2.boundaries[3]; ref <= ref1 ? l <= ref1 : l >= ref1; y2 = ref <= ref1 ? ++l : --l) {
          if (x === x2 && y === y2) {
            return true;
          }
        }
        x2 = room2.boundaries[2] + 1;
        for (y2 = m = ref2 = room2.boundaries[1], ref3 = room2.boundaries[3]; ref2 <= ref3 ? m <= ref3 : m >= ref3; y2 = ref2 <= ref3 ? ++m : --m) {
          if (x === x2 && y === y2) {
            return true;
          }
        }
        y2 = room2.boundaries[1] - 1;
        for (x2 = n = ref4 = room2.boundaries[0], ref5 = room2.boundaries[2]; ref4 <= ref5 ? n <= ref5 : n >= ref5; x2 = ref4 <= ref5 ? ++n : --n) {
          if (x === x2 && y === y2) {
            return true;
          }
        }
        y2 = room2.boundaries[3] + 1;
        for (x2 = o = ref6 = room2.boundaries[0], ref7 = room2.boundaries[2]; ref6 <= ref7 ? o <= ref7 : o >= ref7; x2 = ref6 <= ref7 ? ++o : --o) {
          if (x === x2 && y === y2) {
            return true;
          }
        }
      }
      return false;
    };

    Dungeon.prototype.roomsAdjacent = function(room, room2) {
      var k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, x, y;
      x = room.boundaries[0] - 2;
      for (y = k = ref = room.boundaries[1], ref1 = room.boundaries[3]; ref <= ref1 ? k <= ref1 : k >= ref1; y = ref <= ref1 ? ++k : --k) {
        if (x === room2.boundaries[2] && y >= room2.boundaries[1] && y <= room2.boundaries[3]) {
          return true;
        }
      }
      x = room.boundaries[2] + 2;
      for (y = l = ref2 = room.boundaries[1], ref3 = room.boundaries[3]; ref2 <= ref3 ? l <= ref3 : l >= ref3; y = ref2 <= ref3 ? ++l : --l) {
        if (x === room2.boundaries[0] && y >= room2.boundaries[1] && y <= room2.boundaries[3]) {
          return true;
        }
      }
      y = room.boundaries[1] - 2;
      for (x = m = ref4 = room.boundaries[0], ref5 = room.boundaries[2]; ref4 <= ref5 ? m <= ref5 : m >= ref5; x = ref4 <= ref5 ? ++m : --m) {
        if (y === room2.boundaries[3] && x >= room2.boundaries[0] && x <= room2.boundaries[2]) {
          return true;
        }
      }
      y = room.boundaries[3] + 2;
      for (x = n = ref6 = room.boundaries[0], ref7 = room.boundaries[2]; ref6 <= ref7 ? n <= ref7 : n >= ref7; x = ref6 <= ref7 ? ++n : --n) {
        if (y === room2.boundaries[1] && x >= room2.boundaries[0] && x <= room2.boundaries[2]) {
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.checkIfConnectionExists = function(obj) {
      var connection, k, len, ref;
      ref = this.data.connections;
      for (k = 0, len = ref.length; k < len; k++) {
        connection = ref[k];
        if (connection.room === obj.room && connection.room2 === obj.room2) {
          return true;
        } else if (connection.room2 === obj.room && connection.room2 === obj.room) {
          return true;
        }
      }
      return false;
    };

    return Dungeon;

  })());

  DungeonData = (function() {
    function DungeonData() {}

    return DungeonData;

  })();

  app.controller('main', function($scope, dungeon, $rootScope, $cookies) {
    $scope.cookies = $cookies;
    $scope.dungeon = dungeon;
    $scope.reputation = 0;
    $scope.reputationRate = 0;
    $scope.minions = 0;
    $scope.smallMinions = 0;
    $scope.bigMinions = 0;
    $scope.hugeMinions = 0;
    $scope.buyAllMinionsText = "";
    $scope.buyAllSmallMinionsText = "";
    $scope.buyAllBigMinionsText = "";
    $scope.buyAllHugeMinionsText = "";
    $scope.population = 0;
    $scope.maxPopulation = 0;
    $scope.roomProgressPercent = 0;
    $scope.roomProgressPercentRounded = 0;
    $scope.unitProgressPercent = 0;
    $scope.unitProgressPercentRounded = 0;
    $scope.smallUnitProgressPercent = 0;
    $scope.smallUnitProgressPercentRounded = 0;
    $scope.bigUnitProgressPercent = 0;
    $scope.bigUnitProgressPercentRounded = 0;
    $scope.hugeUnitProgressPercent = 0;
    $scope.hugeUnitProgressPercentRounded = 0;
    $scope.minionUpgradeProgressPercent = 0;
    $scope.minionUpgradeProgressPercentRounded = 0;
    $scope.acolyteUpgradeProgressPercent = 0;
    $scope.acolyteUpgradeProgressPercentRounded = 0;
    $scope.rooms = 0;
    $scope.alerts = [];
    $scope.roomETA = "";
    $scope.unitETA = "";
    $scope.smallUnitETA = "";
    $scope.bigUnitETA = "";
    $scope.hugeUnitETA = "";
    $scope.minionUpgradeETA = "";
    $scope.acolyteUpgradeETA = "";
    $scope.monsters = 0;
    $scope.smallMonsters = 0;
    $scope.bigMonsters = 0;
    $scope.hugeMonsters = 0;
    $scope.monstersActive = 0;
    $scope.buyAllMonstersText = "";
    $scope.buyAllSmallMonstersText = "";
    $scope.BuyAllBigMonstersText = "";
    $scope.BuyAllHugeMonstersText = "";
    $scope.acolytes = 0;
    $scope.smallAcolytes = 0;
    $scope.bigAcolytes = 0;
    $scope.hugeAcolytes = 0;
    $scope.buyAllAcolytesText = "";
    $scope.buyAllSmallAcolytesText = "";
    $scope.buyAllBigAcolytesText = "";
    $scope.buyAllHugeAcolytesText = "";
    $scope.adventurers = 0;
    $scope.treasure = 0;
    $scope.upgradeMinionsText = "";
    $scope.upgradeAcolytesText = "";
    $scope.emptyRooms = 0;
    $scope.devMultiplier = 1;
    $scope.skipDays = 0;
    $scope.skipHours = 0;
    $scope.skipMinutes = 0;
    $scope.enableNarration = true;
    $scope.enableAlerts = true;
    $scope.$watch('dungeon.data.reputation', function(newVal) {
      $scope.reputation = Math.floor(newVal);
      $scope.buyAllMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.minion)) + ")";
      $scope.buyAllSmallMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.smallMinion)) + ")";
      $scope.buyAllBigMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.bigMinion)) + ")";
      $scope.buyAllHugeMinionsText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.hugeMinion)) + ")";
      $scope.buyAllMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.monster)) + ")";
      $scope.buyAllSmallMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.smallMonster)) + ")";
      $scope.buyAllBigMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.bigMonster)) + ")";
      $scope.buyAllHugeMonstersText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.hugeMonster)) + ")";
      $scope.buyAllAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.acolyte)) + ")";
      $scope.buyAllSmallAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.smallAcolyte)) + ")";
      $scope.buyAllBigAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.bigAcolyte)) + ")";
      return $scope.buyAllHugeAcolytesText = "Buy All (" + (dungeon.maxNumberToBuy(unitTypes.hugeAcolyte)) + ")";
    });
    $scope.$watch('dungeon.reputationRate()', function(newVal) {
      return $scope.reputationRate = newVal;
    });
    $scope.$watch('dungeon.data.minions', function(newVal) {
      return $scope.minions = newVal;
    });
    $scope.$watch('dungeon.data.smallMinions', function(newVal) {
      return $scope.smallMinions = newVal;
    });
    $scope.$watch('dungeon.data.bigMinions', function(newVal) {
      return $scope.bigMinions = newVal;
    });
    $scope.$watch('dungeon.data.hugeMinions', function(newVal) {
      return $scope.hugeMinions = newVal;
    });
    $scope.$watch('dungeon.totalPopulation()', function(newVal) {
      return $scope.population = newVal;
    });
    $scope.$watch('dungeon.maxPopulation()', function(newVal) {
      return $scope.maxPopulation = newVal;
    });
    $scope.$watch('dungeon.roomProgressPercent()', function(newVal) {
      $scope.roomProgressPercent = newVal;
      return $scope.roomProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.unitProgressPercent()', function(newVal) {
      $scope.unitProgressPercent = newVal;
      return $scope.unitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.smallUnitProgressPercent()', function(newVal) {
      $scope.smallUnitProgressPercent = newVal;
      return $scope.smallUnitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.bigUnitProgressPercent()', function(newVal) {
      $scope.bigUnitProgressPercent = newVal;
      return $scope.bigUnitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.hugeUnitProgressPercent()', function(newVal) {
      $scope.hugeUnitProgressPercent = newVal;
      return $scope.hugeUnitProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.minionUpgradeProgressPercent()', function(newVal) {
      $scope.minionUpgradeProgressPercent = newVal;
      return $scope.minionUpgradeProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.acolyteUpgradeProgressPercent()', function(newVal) {
      $scope.acolyteUpgradeProgressPercent = newVal;
      return $scope.acolyteUpgradeProgressPercentRounded = Math.floor(newVal);
    });
    $scope.$watch('dungeon.data.rooms', function(newVal) {
      $scope.rooms = newVal;
      if ($scope.rooms > 5 && $scope.enableAlerts === true) {
        return $scope.alerts.push({
          type: 'success',
          msg: 'Room constructed!',
          expired: "false"
        });
      }
    });
    $scope.$watch('dungeon.roomETA()', function(newVal) {
      return $scope.roomETA = newVal;
    });
    $scope.$watch('dungeon.unitETA()', function(newVal) {
      return $scope.unitETA = newVal;
    });
    $scope.$watch('dungeon.smallUnitETA()', function(newVal) {
      return $scope.smallUnitETA = newVal;
    });
    $scope.$watch('dungeon.bigUnitETA()', function(newVal) {
      return $scope.bigUnitETA = newVal;
    });
    $scope.$watch('dungeon.hugeUnitETA()', function(newVal) {
      return $scope.hugeUnitETA = newVal;
    });
    $scope.$watch('dungeon.minionUpgradeETA()', function(newVal) {
      return $scope.minionUpgradeETA = newVal;
    });
    $scope.$watch('dungeon.acolyteUpgradeETA()', function(newVal) {
      return $scope.acolyteUpgradeETA = newVal;
    });
    $scope.$watch('dungeon.data.monsters', function(newVal) {
      return $scope.monsters = newVal;
    });
    $scope.$watch('dungeon.data.smallMonsters', function(newVal) {
      return $scope.smallMonsters = newVal;
    });
    $scope.$watch('dungeon.data.bigMonsters', function(newVal) {
      return $scope.bigMonsters = newVal;
    });
    $scope.$watch('dungeon.data.hugeMonsters', function(newVal) {
      return $scope.hugeMonsters = newVal;
    });
    $scope.$watch('dungeon.monstersActive()', function(newVal) {
      return $scope.monstersActive = newVal;
    });
    $scope.$watch('dungeon.data.acolytes', function(newVal) {
      return $scope.acolytes = newVal;
    });
    $scope.$watch('dungeon.data.smallAcolytes', function(newVal) {
      return $scope.smallAcolytes = newVal;
    });
    $scope.$watch('dungeon.data.bigAcolytes', function(newVal) {
      return $scope.bigAcolytes = newVal;
    });
    $scope.$watch('dungeon.data.hugeAcolytes', function(newVal) {
      return $scope.hugeAcolytes = newVal;
    });
    $scope.$watch('dungeon.data.adventurers', function(newVal) {
      return $scope.adventurers = newVal;
    });
    $scope.$watch('dungeon.data.treasure', function(newVal) {
      return $scope.treasure = newVal;
    });
    $scope.$watch('dungeon.upgradeMinionsText()', function(newVal) {
      return $scope.upgradeMinionsText = newVal;
    });
    $scope.$watch('dungeon.upgradeAcolytesText()', function(newVal) {
      return $scope.upgradeAcolytesText = newVal;
    });
    $scope.$watch('dungeon.emptyRooms()', function(newVal) {
      return $scope.emptyRooms = newVal;
    });
    $scope.closeAlert = function(index) {
      if ($scope.alerts[index] !== void 0) {
        $scope.alerts[index].expired = "true";
        return setTimeout((function() {
          $scope.alerts.splice(index, 1);
        }), 500);
      }
    };
    $scope.setDevMultiplier = function() {
      return $scope.dungeon.data.devMultiplier = this.devMultiplier;
    };
    $scope.timeSkip = function() {
      var days, hours, i, j, k, minutes, monster, ref, results1, seconds, ticks;
      days = this.skipDays;
      hours = (days * 24) + this.skipHours;
      minutes = (hours * 60) + this.skipMinutes;
      seconds = minutes * 60;
      ticks = seconds * 10;
      console.log(ticks);
      this.dungeon.data.devMultiplier *= ticks;
      this.dungeon.updateValuesNoApply();
      this.dungeon.data.devMultiplier /= ticks;
      results1 = [];
      for (i = k = 1, ref = ticks; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        console.log(i, ticks);
        results1.push((function() {
          var l, len, ref1, results2;
          ref1 = this.dungeon.data.monsterObjects;
          results2 = [];
          for (l = 0, len = ref1.length; l < len; l++) {
            monster = ref1[l];
            results2.push((function() {
              var m, ref2, results3;
              results3 = [];
              for (j = m = 0, ref2 = this.dungeon.data.devMultiplier - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; j = 0 <= ref2 ? ++m : --m) {
                results3.push(monster.tick());
              }
              return results3;
            }).call(this));
          }
          return results2;
        }).call(this));
      }
      return results1;
    };
    $scope.toggleNarrationBox = function() {
      if (this.enableNarration === true) {
        $('#narrationContainer').hide();
        return this.enableNarration = false;
      } else if (this.enableNarration === false) {
        $('#narrationContainer').show();
        return this.enableNarration = true;
      }
    };
    $scope.toggleAlerts = function() {
      if (this.enableAlerts === true) {
        return $scope.enableAlerts = false;
      } else if (this.enableAlerts === false) {
        return $scope.enableAlerts = true;
      }
    };
    $scope.wipeOutSaveFile = function() {
      console.log('deleting save');
      return localStorage.removeItem('dungeon');
    };
    $rootScope.save = function() {
      var obj, serialized;
      console.log('saving');
      obj = window.simulator.data;
      serialized = JSON.stringify(obj);
      localStorage.setItem('dungeon', serialized);
      if ($scope.enableAlerts === true) {
        return $scope.alerts.push({
          type: 'success',
          msg: 'Game saved!',
          expired: "false"
        });
      }
    };
    $rootScope.load = function() {
      var i, j, k, l, len, m, monster, monster2, newMap, newMob, obj, ref, ref1, ref2, room;
      console.log('attempting to load');
      obj = localStorage.getItem('dungeon');
      if (obj !== null) {
        obj = JSON.parse(obj);
        console.log('loading');
        for (i = k = 0, ref = obj.monsterObjects.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          monster = obj.monsterObjects[i];
          newMob = null;
          if (monster.type === unitTypes.smallMonster) {
            newMob = new SmallMonster();
          } else if (monster.type === unitTypes.monster) {
            newMob = new Monster();
          } else if (monster.type === unitTypes.bigMonster) {
            newMob = new BigMonster();
          } else if (monster.type === unitTypes.hugeMonster) {
            newMob = new HugeMonster();
          }
          if (newMob !== null) {
            newMob.maxHealth = monster.maxHealth;
            newMob.health = monster.health;
            newMob.hp = monster.hp;
            newMob.maxHp = monster.maxHp;
            newMob.xp = monster.xp;
            newMob.level = monster.level;
            newMob.damage = monster.damage;
            newMob.type = monster.type;
            newMob.uuid = monster.uuid;
            ref1 = obj.roomObjects;
            for (l = 0, len = ref1.length; l < len; l++) {
              room = ref1[l];
              for (j = m = 0, ref2 = room.monsters.length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; j = 0 <= ref2 ? ++m : --m) {
                monster2 = room.monsters[j];
                if (monster2 !== void 0 && monster2 !== null && monster.uuid === monster2.uuid) {
                  room.monsters[j] = newMob;
                }
              }
            }
            obj.monsterObjects[i] = newMob;
          }
        }
        newMap = new Map();
        newMap.sizeX = obj.map.sizeX;
        newMap.sizeY = obj.map.sizeY;
        newMap.roomDimensions = obj.map.roomDimensions;
        newMap.tiles = obj.map.tiles;
        newMap.border = obj.map.border;
        obj.map = newMap;
        obj.firstTick = true;
        obj.lastTickTime = moment().valueOf();
        window.simulator.data = obj;
        window.simulator.formRoomConnections();
        return $rootScope.save();
      }
    };
    return $rootScope.load();
  });

  Monster = (function() {
    function Monster() {
      this.levelUp = bind(this.levelUp, this);
      this.checkForLevelUp = bind(this.checkForLevelUp, this);
      this.tick = bind(this.tick, this);
      this.isActive = bind(this.isActive, this);
      this.maxHealth = 2400;
      this.health = 2400;
      this.hp = 15;
      this.maxHp = 15;
      this.xp = 0;
      this.level = 1;
      this.damage = 0;
      this.uuid = guid();
      this.type = unitTypes.monster;
    }

    Monster.prototype.isActive = function() {
      if (this.health === this.maxHealth) {
        return true;
      } else {
        return false;
      }
    };

    Monster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 160) + 1);
        if (roll === 160) {
          return this.hp += 1;
        }
      }
    };

    Monster.prototype.checkForLevelUp = function() {
      var k, len, level, results1, tier, xpTable;
      xpTable = [300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];
      level = 1;
      for (k = 0, len = xpTable.length; k < len; k++) {
        tier = xpTable[k];
        if (this.xp > tier) {
          level += 1;
        } else {
          break;
        }
      }
      if (level > this.level) {
        results1 = [];
        while (level > this.level) {
          results1.push(this.levelUp());
        }
        return results1;
      }
    };

    Monster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return Monster;

  })();

  SmallMonster = (function(superClass) {
    extend(SmallMonster, superClass);

    function SmallMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      SmallMonster.__super__.constructor.call(this);
      this.hp = 4;
      this.maxHp = 4;
      this.damage = -7;
      this.type = unitTypes.smallMonster;
    }

    SmallMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 640) + 1);
        if (roll === 640) {
          return this.hp += 1;
        }
      }
    };

    SmallMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your small monsters has attained level ' + this.level.toString() + '!');
      this.hp += 2;
      this.maxHp += 2;
      return this.damage += 1;
    };

    return SmallMonster;

  })(Monster);

  BigMonster = (function(superClass) {
    extend(BigMonster, superClass);

    function BigMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      BigMonster.__super__.constructor.call(this);
      this.hp = 60;
      this.maxHp = 60;
      this.damage = 30;
      this.type = unitTypes.bigMonster;
    }

    BigMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 40) + 1);
        if (roll === 40) {
          return this.hp += 1;
        }
      }
    };

    BigMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your big monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return BigMonster;

  })(Monster);

  HugeMonster = (function(superClass) {
    extend(HugeMonster, superClass);

    function HugeMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      HugeMonster.__super__.constructor.call(this);
      this.hp = 240;
      this.maxHp = 240;
      this.damage = 90;
      this.type = unitTypes.hugeMonster;
    }

    HugeMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 10) + 1);
        if (roll === 10) {
          return this.hp += 1;
        }
      }
    };

    HugeMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your huge monsters has attained level ' + this.level.toString() + '!');
      this.hp += 28;
      this.maxHp += 28;
      return this.damage += 1;
    };

    return HugeMonster;

  })(Monster);

  Minion = (function() {
    function Minion() {
      this.maxHealth = 2400;
      this.health = 2400;
      this.labor = 16;
    }

    return Minion;

  })();

  SmallMinion = (function(superClass) {
    extend(SmallMinion, superClass);

    function SmallMinion() {
      SmallMinion.__super__.constructor.call(this);
      this.labor = 1;
    }

    return SmallMinion;

  })(Minion);

  BigMinion = (function(superClass) {
    extend(BigMinion, superClass);

    function BigMinion() {
      BigMinion.__super__.constructor.call(this);
      this.labor = 256;
    }

    return BigMinion;

  })(Minion);

  HugeMinion = (function(superClass) {
    extend(HugeMinion, superClass);

    function HugeMinion() {
      HugeMinion.__super__.constructor.call(this);
      this.labor = 4096;
    }

    return HugeMinion;

  })(Minion);

  Acolyte = (function() {
    function Acolyte() {
      this.maxHealth = 2400;
      this.health = 2400;
      this.reputation = 16;
    }

    return Acolyte;

  })();

  SmallAcolyte = (function(superClass) {
    extend(SmallAcolyte, superClass);

    function SmallAcolyte() {
      SmallAcolyte.__super__.constructor.call(this);
      this.reputation = 1;
    }

    return SmallAcolyte;

  })(Acolyte);

  BigAcolyte = (function(superClass) {
    extend(BigAcolyte, superClass);

    function BigAcolyte() {
      BigAcolyte.__super__.constructor.call(this);
      this.reputation = 256;
    }

    return BigAcolyte;

  })(Acolyte);

  HugeAcolyte = (function(superClass) {
    extend(HugeAcolyte, superClass);

    function HugeAcolyte() {
      HugeAcolyte.__super__.constructor.call(this);
      this.reputation = 4096;
    }

    return HugeAcolyte;

  })(Acolyte);

  Adventurer = (function() {
    function Adventurer() {
      this.hp = 13;
    }

    return Adventurer;

  })();

  Room = (function() {
    function Room() {
      this.population = 0;
      this.size = 5;
      this.occupantType = unitTypes.none;
      this.monsters = [];
      this.minions = [];
      this.acolytes = [];
      this.boundaries = [];
    }

    return Room;

  })();

  Map = (function() {
    function Map() {
      this.determineBounds = bind(this.determineBounds, this);
      this.determineStep = bind(this.determineStep, this);
      this.checkOpenings = bind(this.checkOpenings, this);
      this.excavateDoor = bind(this.excavateDoor, this);
      this.sizeX = 64;
      this.sizeY = 64;
      this.roomDimensions = 5;
      this.tiles = [];
      this.border = 1;
      this.initFillMap();
      this.initialRoomBoundaries = this.digInitialRoom();
    }

    Map.prototype.initFillMap = function() {
      var i, j, k, ref, results1;
      results1 = [];
      for (i = k = 0, ref = this.sizeX - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        this.tiles[i] = [];
        results1.push((function() {
          var l, ref1, results2;
          results2 = [];
          for (j = l = 0, ref1 = this.sizeY - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            results2.push(this.tiles[i][j] = 'W');
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    Map.prototype.digInitialRoom = function() {
      var i, j, k, l, ref, ref1, ref2, ref3, rollX, rollY;
      rollX = Math.floor((Math.random() * (this.sizeX - (this.border * 2) - this.roomDimensions) - 1) + this.border);
      rollY = Math.floor((Math.random() * (this.sizeY - (this.border * 2) - this.roomDimensions) - 1) + this.border);
      for (i = k = ref = rollX, ref1 = rollX + this.roomDimensions - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
        for (j = l = ref2 = rollY, ref3 = rollY + this.roomDimensions - 1; ref2 <= ref3 ? l <= ref3 : l >= ref3; j = ref2 <= ref3 ? ++l : --l) {
          this.tiles[i][j] = ' ';
        }
      }
      return [rollX, rollY, rollX + this.roomDimensions - 1, rollY + this.roomDimensions - 1];
    };

    Map.prototype.excavate = function(x, y, facing) {
      var i, j, k, l, m, n, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, xMax, xStart, xStep, yMax, yStart, yStep;
      ref = this.determineStep(facing), xStep = ref[0], yStep = ref[1];
      ref1 = this.determineBounds(x, y, xStep, yStep, facing), xMax = ref1[0], yMax = ref1[1];
      if (facing === 0 || facing === 2) {
        xStart = x;
        yStart = y + yStep;
      } else if (facing === 1 || facing === 3) {
        xStart = x + xStep;
        yStart = y;
      }
      for (i = k = ref2 = xStart - xStep, ref3 = xMax + xStep, ref4 = xStep; ref4 > 0 ? k <= ref3 : k >= ref3; i = k += ref4) {
        for (j = l = ref5 = yStart - yStep, ref6 = yMax + yStep, ref7 = yStep; ref7 > 0 ? l <= ref6 : l >= ref6; j = l += ref7) {
          if (this.tiles[i] === void 0) {
            return [false, void 0];
          }
          if (this.tiles[i][j] !== 'W') {
            return [false, void 0];
          }
        }
      }
      ref8 = this.excavateDoor(x, y, xStep, yStep, facing), x = ref8[0], y = ref8[1];
      for (i = m = ref9 = x, ref10 = xMax, ref11 = xStep; ref11 > 0 ? m <= ref10 : m >= ref10; i = m += ref11) {
        for (j = n = ref12 = y, ref13 = yMax, ref14 = yStep; ref14 > 0 ? n <= ref13 : n >= ref13; j = n += ref14) {
          this.tiles[i][j] = ' ';
        }
      }
      return [true, [Math.min(x, xMax), Math.min(y, yMax), Math.max(x, xMax), Math.max(y, yMax)]];
    };

    Map.prototype.excavateDoor = function(x, y, xStep, yStep, facing) {
      var valid, xDoor, yDoor;
      valid = false;
      while (valid === false) {
        if (facing === 0 || facing === 2) {
          xDoor = Math.floor(Math.random() * 5) + x;
          yDoor = y;
        } else if (facing === 1 || facing === 3) {
          xDoor = x;
          yDoor = Math.floor(Math.random() * 5) + y;
        }
        valid = this.checkOpenings(xDoor, yDoor);
      }
      this.tiles[xDoor][yDoor] = ' ';
      if (facing === 0 || facing === 2) {
        y += yStep;
      } else if (facing === 1 || facing === 3) {
        x += xStep;
      }
      return [x, y];
    };

    Map.prototype.checkOpenings = function(x, y) {
      var count;
      count = 0;
      if (this.tiles[x - 1][y] === ' ') {
        count += 1;
      }
      if (this.tiles[x + 1][y] === ' ') {
        count += 1;
      }
      if (this.tiles[x][y - 1] === ' ') {
        count += 1;
      }
      if (this.tiles[x][y + 1] === ' ') {
        count += 1;
      }
      if (count === 1) {
        return true;
      }
      return false;
    };

    Map.prototype.determineStep = function(facing) {
      if (facing === 0) {
        return [1, 1];
      }
      if (facing === 1) {
        return [-1, 1];
      }
      if (facing === 2) {
        return [1, -1];
      }
      if (facing === 3) {
        return [1, 1];
      }
    };

    Map.prototype.determineBounds = function(x, y, xStep, yStep, facing) {
      if (facing === 0 || facing === 2) {
        return [x + (xStep * (this.roomDimensions - 1)), y + (yStep * this.roomDimensions)];
      }
      if (facing === 1 || facing === 3) {
        return [x + (xStep * this.roomDimensions), y + (yStep * (this.roomDimensions - 1))];
      }
    };

    return Map;

  })();

  RoomConnection = (function() {
    function RoomConnection() {}

    RoomConnection.room = -1;

    RoomConnection.room2 = -1;

    return RoomConnection;

  })();

  unitTypes = {
    none: -1,
    minion: 0,
    monster: 1,
    acolyte: 2,
    smallMinion: 3,
    bigMinion: 4,
    smallMonster: 5,
    bigMonster: 6,
    smallAcolyte: 7,
    bigAcolyte: 8,
    hugeMinion: 9,
    hugeMonster: 10,
    hugeAcolyte: 11
  };

  guid = function() {
    var s4;
    s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  };

}).call(this);

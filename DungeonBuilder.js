// Generated by CoffeeScript 1.10.0
(function() {
  var Adventurer, BigMonster, Dungeon, Monster, Room, SmallMonster, unitTypes,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Dungeon = (function() {
    function Dungeon() {
      this.adjustMaxPopulation = bind(this.adjustMaxPopulation, this);
      this.addMonsterToRoom = bind(this.addMonsterToRoom, this);
      this.allocateRoom = bind(this.allocateRoom, this);
      this.narrate = bind(this.narrate, this);
      this.defeatAdventurer = bind(this.defeatAdventurer, this);
      this.numActiveMonsters = bind(this.numActiveMonsters, this);
      this.monsterWithLowestHp = bind(this.monsterWithLowestHp, this);
      this.anyMonstersActive = bind(this.anyMonstersActive, this);
      this.doCombat = bind(this.doCombat, this);
      this.encounterMonsters = bind(this.encounterMonsters, this);
      this.runDungeon = bind(this.runDungeon, this);
      this.optimizeRemoval = bind(this.optimizeRemoval, this);
      this.upgradeAcolytes = bind(this.upgradeAcolytes, this);
      this.upgradeMinions = bind(this.upgradeMinions, this);
      this.sellBigAcolyte = bind(this.sellBigAcolyte, this);
      this.sellSmallAcolyte = bind(this.sellSmallAcolyte, this);
      this.sellAcolyte = bind(this.sellAcolyte, this);
      this.sellBigMonster = bind(this.sellBigMonster, this);
      this.sellSmallMonster = bind(this.sellSmallMonster, this);
      this.sellMonster = bind(this.sellMonster, this);
      this.sellBigMinion = bind(this.sellBigMinion, this);
      this.sellSmallMinion = bind(this.sellSmallMinion, this);
      this.sellMinion = bind(this.sellMinion, this);
      this.buyAllBigAcolytes = bind(this.buyAllBigAcolytes, this);
      this.buyAllSmallAcolytes = bind(this.buyAllSmallAcolytes, this);
      this.buyAllAcolytes = bind(this.buyAllAcolytes, this);
      this.buyAllBigMonsters = bind(this.buyAllBigMonsters, this);
      this.buyAllSmallMonsters = bind(this.buyAllSmallMonsters, this);
      this.buyAllMonsters = bind(this.buyAllMonsters, this);
      this.buyAllBigMinions = bind(this.buyAllBigMinions, this);
      this.buyAllSmallMinions = bind(this.buyAllSmallMinions, this);
      this.buyAllMinions = bind(this.buyAllMinions, this);
      this.buyBigAcolyte = bind(this.buyBigAcolyte, this);
      this.buySmallAcolyte = bind(this.buySmallAcolyte, this);
      this.buyAcolyte = bind(this.buyAcolyte, this);
      this.buyBigMonster = bind(this.buyBigMonster, this);
      this.buySmallMonster = bind(this.buySmallMonster, this);
      this.buyMonster = bind(this.buyMonster, this);
      this.buyBigMinion = bind(this.buyBigMinion, this);
      this.buySmallMinion = bind(this.buySmallMinion, this);
      this.buyMinion = bind(this.buyMinion, this);
      this.maxNumberToBuy = bind(this.maxNumberToBuy, this);
      this.monstersActive = bind(this.monstersActive, this);
      this.availablePopulation = bind(this.availablePopulation, this);
      this.maxPopulation = bind(this.maxPopulation, this);
      this.totalPopulation = bind(this.totalPopulation, this);
      this.roomCost = bind(this.roomCost, this);
      this.setRoomETA = bind(this.setRoomETA, this);
      this.updateUpgradeBox = bind(this.updateUpgradeBox, this);
      this.updateRoomBox = bind(this.updateRoomBox, this);
      this.updateTreasureBox = bind(this.updateTreasureBox, this);
      this.updateAcolyteBox = bind(this.updateAcolyteBox, this);
      this.updateMonsterBox = bind(this.updateMonsterBox, this);
      this.updateMinionBox = bind(this.updateMinionBox, this);
      this.updateReputationBox = bind(this.updateReputationBox, this);
      this.updateValues = bind(this.updateValues, this);
      this.tick = bind(this.tick, this);
      var i, j, k, ref, ref1;
      this.minions = 5;
      this.smallMinions = 0;
      this.bigMinions = 0;
      this.monsters = 5;
      this.smallMonsters = 0;
      this.bigMonsters = 0;
      this.monsterObjects = [];
      for (i = j = 0, ref = this.monsters - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        this.monsterObjects[i] = new Monster();
      }
      this.acolytes = 5;
      this.smallAcolytes = 0;
      this.bigAcolytes = 0;
      this.treasure = 10;
      this.roomProgress = 0;
      this.rooms = 5;
      this.roomObjects = [];
      this.roomObjects[0] = new Room();
      this.roomObjects[0].population = 5;
      this.roomObjects[0].occupantType = unitTypes.minion;
      this.roomObjects[1] = new Room();
      this.roomObjects[1].population = 5;
      this.roomObjects[1].occupantType = unitTypes.monster;
      this.roomObjects[1].population = 5;
      for (i = k = 0, ref1 = this.monsters - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
        this.roomObjects[1].monsters[i] = this.monsterObjects[i];
      }
      this.roomObjects[2] = new Room();
      this.roomObjects[2].occupantType = unitTypes.acolyte;
      this.roomObjects[2].population = 5;
      this.roomObjects[3] = new Room();
      this.roomObjects[4] = new Room();
      this.adventurers = 0;
      this.reputation = 0;
      this.devMultiplier = 1;
      this.minionMultiplier = 1;
      this.acolyteMultiplier = 1;
      this.minionUpgradeCost = Math.floor(15000 * 0.2);
      this.acolyteUpgradeCost = Math.floor(15000 * 0.2);
      this.cost = 1500;
      $('#buyMinion').on('click', this.buyMinion);
      $('#buyMonster').on('click', this.buyMonster);
      $('#buyAcolyte').on('click', this.buyAcolyte);
      $('#buyAllMinions').on('click', this.buyAllMinions);
      $('#buyAllMonsters').on('click', this.buyAllMonsters);
      $('#buyAllAcolytes').on('click', this.buyAllAcolytes);
      $('#sellMinion').on('click', this.sellMinion);
      $('#sellMonster').on('click', this.sellMonster);
      $('#sellAcolyte').on('click', this.sellAcolyte);
      $('#buySmallMinion').on('click', this.buySmallMinion);
      $('#buyAllSmallMinions').on('click', this.buyAllSmallMinions);
      $('#sellSmallMinion').on('click', this.sellSmallMinion);
      $('#buyBigMinion').on('click', this.buyBigMinion);
      $('#buyAllBigMinions').on('click', this.buyAllBigMinions);
      $('#sellBigMinion').on('click', this.sellBigMinion);
      $('#buySmallMonster').on('click', this.buySmallMonster);
      $('#buyAllSmallMonsters').on('click', this.buyAllSmallMonsters);
      $('#sellSmallMonster').on('click', this.sellSmallMonster);
      $('#buyBigMonster').on('click', this.buyBigMonster);
      $('#buyAllBigMonsters').on('click', this.buyAllBigMonsters);
      $('#sellBigMonster').on('click', this.sellBigMonster);
      $('#buySmallAcolyte').on('click', this.buySmallAcolyte);
      $('#buyAllSmallAcolytes').on('click', this.buyAllSmallAcolytes);
      $('#sellSmallAcolyte').on('click', this.sellSmallAcolyte);
      $('#buyBigAcolyte').on('click', this.buyBigAcolyte);
      $('#buyAllBigAcolytes').on('click', this.buyAllBigAcolytes);
      $('#sellBigAcolyte').on('click', this.sellBigAcolyte);
      $('#upgradeMinions').on('click', this.upgradeMinions);
      $('#upgradeAcolytes').on('click', this.upgradeAcolytes);
    }

    Dungeon.prototype.tick = function() {
      var i, j, len, monster, ref, results;
      this.updateValues();
      this.updateTreasureBox();
      this.updateMinionBox();
      this.updateMonsterBox();
      this.updateAcolyteBox();
      this.updateReputationBox();
      this.updateRoomBox();
      this.updateUpgradeBox();
      ref = this.monsterObjects;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (i = k = 0, ref1 = this.devMultiplier - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
            results1.push(monster.tick());
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Dungeon.prototype.updateValues = function() {
      var adventurerRoll, i, j, ref, results;
      this.roomProgress += ((this.smallMinions / 4) + this.minions + (this.bigMinions * 4)) * this.devMultiplier * this.minionMultiplier;
      if (this.roomProgress >= this.roomCost()) {
        this.roomProgress -= this.roomCost();
        this.rooms += 1;
        this.roomObjects[this.rooms - 1] = new Room();
      }
      this.reputation += ((this.smallAcolytes / 4) + this.acolytes + (this.bigAcolytes * 4)) * this.devMultiplier * this.acolyteMultiplier;
      results = [];
      for (i = j = 0, ref = Math.floor(this.treasure * this.devMultiplier) - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        adventurerRoll = Math.floor((Math.random() * 14500) + 1);
        if (adventurerRoll === 14500) {
          results.push(this.runDungeon());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Dungeon.prototype.updateReputationBox = function() {
      $('#reputationCount').text(Math.floor(this.reputation));
      return $('#reputationRate').text(Math.floor(((this.smallAcolytes * 2.5) + (this.acolytes * 10) + (this.bigAcolytes * 40)) * this.acolyteMultiplier));
    };

    Dungeon.prototype.updateMinionBox = function() {
      var roomProgressPercent;
      $('#minionCount').text(this.minions);
      $('#smallMinionCount').text(this.smallMinions);
      $('#bigMinionCount').text(this.bigMinions);
      $('#buyAllMinions').text("Buy All (" + (this.maxNumberToBuy(this.cost)) + ")");
      $('#buyAllSmallMinions').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost / 4))) + ")");
      $('#buyAllBigMinions').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost * 2.8))) + ")");
      $('#population').text(this.totalPopulation());
      $('#maxPopulation').text(this.maxPopulation());
      roomProgressPercent = (this.roomProgress / this.roomCost() * 100).toString();
      $('#roomCount').text(this.rooms);
      this.updateProgressBar($('#roomBar'), roomProgressPercent);
      return this.setRoomETA();
    };

    Dungeon.prototype.updateMonsterBox = function() {
      $('#monsterCount').text(this.monsters);
      $('#smallMonsterCount').text(this.smallMonsters);
      $('#bigMonsterCount').text(this.bigMonsters);
      $('#monsterActiveCount').text(this.monstersActive());
      $('#buyAllMonsters').text("Buy All (" + (this.maxNumberToBuy(this.cost)) + ")");
      $('#buyAllSmallMonsters').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost / 4))) + ")");
      return $('#buyAllBigMonsters').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost * 2.8))) + ")");
    };

    Dungeon.prototype.updateAcolyteBox = function() {
      $('#acolyteCount').text(this.acolytes);
      $('#smallAcolyteCount').text(this.smallAcolytes);
      $('#bigAcolyteCount').text(this.bigAcolytes);
      $('#acolyteReputationRate').text(Math.floor(((this.smallAcolytes * 2.5) + (this.acolytes * 10) + (this.bigAcolytes * 40)) * this.acolyteMultiplier));
      $('#buyAllAcolytes').text("Buy All (" + (this.maxNumberToBuy(this.cost)) + ")");
      $('#buyAllSmallAcolytes').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost / 4))) + ")");
      return $('#buyAllBigAcolytes').text("Buy All (" + (this.maxNumberToBuy(Math.floor(this.cost * 2.8))) + ")");
    };

    Dungeon.prototype.updateTreasureBox = function() {
      $('#adventurerCount').text(this.adventurers);
      return $('#treasureCount').text(this.treasure);
    };

    Dungeon.prototype.updateRoomBox = function() {
      var i, j, ref, room, text;
      text = "Room Summary:<br><br>";
      for (i = j = 0, ref = this.rooms - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        room = this.roomObjects[i];
        text += "Room " + (i + 1).toString() + ":<br>Contains ";
        if (room.occupantType === unitTypes.none) {
          text += "nothing";
        } else if (room.occupantType === unitTypes.minion) {
          text += "minions";
        } else if (room.occupantType === unitTypes.smallMinion) {
          text += "mini-ons";
        } else if (room.occupantType === unitTypes.bigMinion) {
          text += "big minions";
        } else if (room.occupantType === unitTypes.monster) {
          text += "monsters";
        } else if (room.occupantType === unitTypes.smallMonster) {
          text += "small monsters";
        } else if (room.occupantType === unitTypes.bigMonster) {
          text += "big monsters";
        } else if (room.occupantType === unitTypes.acolyte) {
          text += "acolytes";
        } else if (room.occupantType === unitTypes.smallAcolyte) {
          text += "small acolytes";
        } else if (room.occupantType === unitTypes.bigAcolyte) {
          text += "big acolytes";
        }
        text += ".<br>Population: " + room.population.toString() + "/" + room.size.toString() + "<br><br>";
      }
      return document.getElementById('roomsPanel').innerHTML = text;
    };

    Dungeon.prototype.updateUpgradeBox = function() {
      $('#upgradeMinions').text("Upgrade Minions (" + this.minionUpgradeCost + " reputation)");
      return $('#upgradeAcolytes').text("Upgrade Acolytes (" + this.acolyteUpgradeCost + " reputation)");
    };

    Dungeon.prototype.setRoomETA = function() {
      var duration, eta, moment_time, rate, remaining, specific;
      remaining = this.roomCost() - this.roomProgress;
      rate = ((this.smallMinions / 4) + this.minions + (this.bigMinions * 4)) * this.devMultiplier * this.minionMultiplier;
      eta = Math.floor(remaining / rate);
      duration = moment.duration(eta * 100);
      moment_time = duration.humanize();
      specific = "";
      if (duration.years() > 0) {
        specific += (duration.years()) + " years ";
      }
      if (duration.months() > 0) {
        specific += (duration.months()) + " months ";
      }
      if (duration.days() > 0) {
        specific += (duration.days()) + " days ";
      }
      if (duration.hours() > 0) {
        specific += (duration.hours()) + " hours ";
      }
      if (duration.minutes() > 0) {
        specific += (duration.minutes()) + " minutes ";
      }
      if (duration.seconds() > 0) {
        specific += (duration.seconds()) + " seconds ";
      }
      return $('#roomETA').text(specific);
    };

    Dungeon.prototype.updateProgressBar = function(bar, percent) {
      return bar.width(percent + "%");
    };

    Dungeon.prototype.roomCost = function() {
      var costToBuild;
      costToBuild = 12240;
      if (this.rooms >= 100) {
        costToBuild = 1328065992;
      } else if (this.rooms >= 30) {
        costToBuild = 6324123;
      } else if (this.rooms >= 20) {
        costToBuild = 799632;
      }
      return costToBuild;
    };

    Dungeon.prototype.totalPopulation = function() {
      return this.minions + this.monsters + this.acolytes + this.smallMinions + this.bigMinions + this.smallMonsters + this.bigMonsters + this.smallAcolytes + this.bigAcolytes;
    };

    Dungeon.prototype.maxPopulation = function() {
      var count, j, len, ref, room;
      count = 0;
      ref = this.roomObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        room = ref[j];
        count += room.size;
      }
      return count;
    };

    Dungeon.prototype.availablePopulation = function() {
      return Math.max(this.maxPopulation() - this.totalPopulation(), 0);
    };

    Dungeon.prototype.monstersActive = function() {
      var count, j, len, monster, ref;
      count = 0;
      ref = this.monsterObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.maxNumberToBuy = function(cost) {
      return Math.min(Math.floor(this.reputation / cost), this.availablePopulation());
    };

    Dungeon.prototype.buyMinion = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.minion)) {
          this.minions += 1;
          return this.reputation -= this.cost;
        }
      }
    };

    Dungeon.prototype.buySmallMinion = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMinion)) {
          this.smallMinions += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigMinion = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMinion)) {
          this.bigMinions += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyMonster = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.monster)) {
          this.reputation -= this.cost;
          return this.monsters += 1;
        }
      }
    };

    Dungeon.prototype.buySmallMonster = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallMonster)) {
          this.smallMonsters += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigMonster = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigMonster)) {
          this.bigMonsters += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyAcolyte = function() {
      if (this.reputation > this.cost) {
        if (this.allocateRoom(unitTypes.acolyte)) {
          this.reputation -= this.cost;
          return this.acolytes += 1;
        }
      }
    };

    Dungeon.prototype.buySmallAcolyte = function() {
      var smallCost;
      smallCost = Math.floor(this.cost / 4);
      if (this.reputation > smallCost) {
        if (this.allocateRoom(unitTypes.smallAcolyte)) {
          this.smallAcolytes += 1;
          return this.reputation -= smallCost;
        }
      }
    };

    Dungeon.prototype.buyBigAcolyte = function() {
      var bigCost;
      bigCost = Math.floor(this.cost * 2.8);
      if (this.reputation > bigCost) {
        if (this.allocateRoom(unitTypes.bigAcolyte)) {
          this.bigAcolytes += 1;
          return this.reputation -= bigCost;
        }
      }
    };

    Dungeon.prototype.buyAllMinions = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallMinions = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buySmallMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigMinions = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyBigMinion());
      }
      return results;
    };

    Dungeon.prototype.buyAllMonsters = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallMonsters = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buySmallMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigMonsters = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyBigMonster());
      }
      return results;
    };

    Dungeon.prototype.buyAllAcolytes = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(this.cost);
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyAcolyte());
      }
      return results;
    };

    Dungeon.prototype.buyAllSmallAcolytes = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost / 4));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buySmallAcolyte());
      }
      return results;
    };

    Dungeon.prototype.buyAllBigAcolytes = function() {
      var i, j, number, ref, results;
      number = this.maxNumberToBuy(Math.floor(this.cost * 2.8));
      results = [];
      for (i = j = 0, ref = number - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buyBigAcolyte());
      }
      return results;
    };

    Dungeon.prototype.sellMinion = function() {
      if (this.minions > 1) {
        this.minions -= 1;
        return this.optimizeRemoval(unitTypes.minion);
      }
    };

    Dungeon.prototype.sellSmallMinion = function() {
      if (this.smallMinions > 0) {
        this.smallMinions -= 1;
        return this.optimizeRemoval(unitTypes.smallMinion);
      }
    };

    Dungeon.prototype.sellBigMinion = function() {
      if (this.bigMinions > 0) {
        this.bigMinions -= 1;
        return this.optimizeRemoval(unitTypes.bigMinion);
      }
    };

    Dungeon.prototype.sellMonster = function() {
      if (this.monsters > 0) {
        this.monsters -= 1;
        return this.optimizeRemoval(unitTypes.monster);
      }
    };

    Dungeon.prototype.sellSmallMonster = function() {
      if (this.smallMonsters > 0) {
        this.smallMonsters -= 1;
        return this.optimizeRemoval(unitTypes.smallMonster);
      }
    };

    Dungeon.prototype.sellBigMonster = function() {
      if (this.bigMonsters > 0) {
        this.bigMonsters -= 1;
        return this.optimizeRemoval(unitTypes.bigMonster);
      }
    };

    Dungeon.prototype.sellAcolyte = function() {
      if (this.acolytes > 1) {
        this.acolytes -= 1;
        return this.optimizeRemoval(unitTypes.acolyte);
      }
    };

    Dungeon.prototype.sellSmallAcolyte = function() {
      if (this.smallAcolytes > 0) {
        this.smallAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.smallAcolyte);
      }
    };

    Dungeon.prototype.sellBigAcolyte = function() {
      if (this.bigAcolytes > 0) {
        this.bigAcolytes -= 1;
        return this.optimizeRemoval(unitTypes.bigAcolyte);
      }
    };

    Dungeon.prototype.upgradeMinions = function() {
      if (this.reputation >= this.minionUpgradeCost) {
        this.reputation -= this.minionUpgradeCost;
        this.minionMultiplier = this.minionMultiplier * 1.2;
        return this.minionUpgradeCost = Math.floor(this.minionUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.upgradeAcolytes = function() {
      if (this.reputation >= this.acolyteUpgradeCost) {
        this.reputation -= this.acolyteUpgradeCost;
        this.acolyteMultiplier = this.acolyteMultiplier * 1.2;
        return this.acolyteUpgradeCost = Math.floor(this.acolyteUpgradeCost * 2 * 1.2);
      }
    };

    Dungeon.prototype.optimizeRemoval = function(type) {
      var j, len, ref, room, roomSelected;
      roomSelected = null;
      ref = this.roomObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        room = ref[j];
        if (room.occupantType !== type) {
          continue;
        }
        if (roomSelected === null && room.population > 0) {
          roomSelected = room;
        } else if (room.population < roomSelected.population && room.population > 0) {
          roomSelected = room;
        }
      }
      roomSelected.population -= 1;
      if (roomSelected.population === 0) {
        return roomSelected.occupantType = unitTypes.none;
      }
    };

    Dungeon.prototype.runDungeon = function() {
      var adventurer, j, len, ref, room;
      this.narrate('An adventurer arrives!');
      adventurer = new Adventurer();
      ref = this.roomObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        room = ref[j];
        if (room.occupantType === unitTypes.monster) {
          console.log(room);
          if (this.encounterMonsters(adventurer, room)) {
            return;
          }
        }
      }
      if (this.treasure > 1) {
        this.treasure -= 1;
        this.narrate('The adventurer has successfully beaten all of your monsters! They take one of your treasures!');
        return console.log("activemonsters: " + (this.monstersActive()));
      } else {
        return this.narrate('The adventurer finds nothing and leaves.');
      }
    };

    Dungeon.prototype.encounterMonsters = function(adventurer, room) {
      this.doCombat(adventurer, room);
      if (adventurer.hp <= 0) {
        this.defeatAdventurer(room);
        return true;
      } else {
        return false;
      }
    };

    Dungeon.prototype.doCombat = function(adventurer, room) {
      var j, len, monster, ref, results, turnRoll;
      if (this.anyMonstersActive(room)) {
        turnRoll = Math.floor((Math.random() * 2) + 1);
        results = [];
        while (adventurer.hp > 0 && this.anyMonstersActive(room)) {
          if (turnRoll === 1) {
            monster = this.monsterWithLowestHp(room);
            monster.hp -= Math.floor((Math.random() * 8) + 3);
            turnRoll = 2;
            if (monster.hp <= 0) {
              monster.hp = 0;
              monster.health = 0;
              results.push(this.narrate('One of your monsters has been disabled by an adventurer.'));
            } else {
              results.push(void 0);
            }
          } else if (turnRoll === 2) {
            ref = room.monsters;
            for (j = 0, len = ref.length; j < len; j++) {
              monster = ref[j];
              adventurer.hp -= Math.max(Math.floor((Math.random() * 12) + 4 + monster.damage), 0);
            }
            results.push(turnRoll = 1);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    Dungeon.prototype.anyMonstersActive = function(room) {
      var j, len, monster, ref;
      ref = room.monsters;
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (monster.isActive()) {
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.monsterWithLowestHp = function(room) {
      var j, len, lowestHp, monster, monsterSelected, ref;
      lowestHp = 1000000;
      monsterSelected = null;
      ref = room.monsters;
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (monster.hp < lowestHp && monster.isActive()) {
          lowestHp = monster.hp;
          monsterSelected = monster;
        }
      }
      return monsterSelected;
    };

    Dungeon.prototype.numActiveMonsters = function(room) {
      var count, j, len, monster, ref;
      count = 0;
      ref = room.monsters;
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (monster.isActive()) {
          count += 1;
        }
      }
      return count;
    };

    Dungeon.prototype.defeatAdventurer = function(room) {
      var j, len, monster, ref, type, xp;
      this.adventurers += 1;
      this.treasure += 1;
      xp = Math.floor(100 / this.numActiveMonsters(room));
      ref = room.monsters;
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (monster.isActive()) {
          monster.xp += xp;
          monster.checkForLevelUp();
        }
      }
      if (room.occupantType === unitTypes.monster) {
        type = "monsters";
      } else if (room.occupantType === unitTypes.smallMonster) {
        type = "small monsters";
      } else if (room.occupantType === unitTypes.bigMonster) {
        type = "big monsters";
      }
      return this.narrate('Some of your ' + type + ' have slain the adventurer! You take their treasure!');
    };

    Dungeon.prototype.narrate = function(text) {
      document.getElementById('narrationContainer').innerHTML += '<br>' + text;
      return document.getElementById('narrationContainer').scrollTop = document.getElementById('narrationContainer').scrollHeight;
    };

    Dungeon.prototype.allocateRoom = function(type) {
      var j, len, ref, room;
      ref = this.roomObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        room = ref[j];
        if (room.occupantType === unitTypes.none) {
          room.occupantType = type;
          room.population += 1;
          this.addMonsterToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        } else if (room.occupantType === type && room.population < room.size) {
          room.population += 1;
          this.addMonsterToRoom(room);
          this.adjustMaxPopulation(room);
          return true;
        }
      }
      return false;
    };

    Dungeon.prototype.addMonsterToRoom = function(room) {
      var monster;
      if (room.occupantType === unitTypes.monster || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.bigMonster) {
        if (room.occupantType === unitTypes.monster) {
          monster = new Monster();
        } else if (room.occupantType === unitTypes.smallMonster) {
          monster = new SmallMonster();
        } else if (room.occupantType === unitTypes.bigMonster) {
          monster = new BigMonster();
        }
        this.monsterObjects[this.monsters + this.smallMonsters + this.bigMonsters] = monster;
        return room.monsters[room.population - 1] = monster;
      }
    };

    Dungeon.prototype.adjustMaxPopulation = function(room) {
      if (room.occupantType === unitTypes.smallMinion || room.occupantType === unitTypes.smallMonster || room.occupantType === unitTypes.smallAcolyte) {
        return room.size = 10;
      } else if (room.occupantType === unitTypes.bigMinion || room.occupantType === unitTypes.bigMonster || room.occupantType === unitTypes.bigAcolyte) {
        return room.size = 2;
      } else {
        return room.size = 5;
      }
    };

    return Dungeon;

  })();

  Monster = (function() {
    function Monster() {
      this.levelUp = bind(this.levelUp, this);
      this.checkForLevelUp = bind(this.checkForLevelUp, this);
      this.tick = bind(this.tick, this);
      this.isActive = bind(this.isActive, this);
      this.maxHealth = 2400;
      this.health = 2400;
      this.hp = 15;
      this.maxHp = 15;
      this.xp = 0;
      this.level = 1;
      this.damage = 0;
    }

    Monster.prototype.isActive = function() {
      if (this.health === this.maxHealth) {
        return true;
      } else {
        return false;
      }
    };

    Monster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 160) + 1);
        if (roll === 160) {
          return this.hp += 1;
        }
      }
    };

    Monster.prototype.checkForLevelUp = function() {
      var j, len, level, results, tier, xpTable;
      xpTable = [300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];
      level = 1;
      for (j = 0, len = xpTable.length; j < len; j++) {
        tier = xpTable[j];
        if (this.xp > tier) {
          level += 1;
        } else {
          break;
        }
      }
      if (level > this.level) {
        results = [];
        while (level > this.level) {
          results.push(this.levelUp());
        }
        return results;
      }
    };

    Monster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return Monster;

  })();

  SmallMonster = (function(superClass) {
    extend(SmallMonster, superClass);

    function SmallMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      SmallMonster.__super__.constructor.call(this);
      this.hp = 4;
      this.maxHp = 4;
      this.damage = -7;
    }

    SmallMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 640) + 1);
        if (roll === 640) {
          return this.hp += 1;
        }
      }
    };

    SmallMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your small monsters has attained level ' + this.level.toString() + '!');
      this.hp += 2;
      this.maxHp += 2;
      return this.damage += 1;
    };

    return SmallMonster;

  })(Monster);

  BigMonster = (function(superClass) {
    extend(BigMonster, superClass);

    function BigMonster() {
      this.levelUp = bind(this.levelUp, this);
      this.tick = bind(this.tick, this);
      BigMonster.__super__.constructor.call(this);
      this.hp = 60;
      this.maxHp = 60;
      this.damage = 30;
    }

    BigMonster.prototype.tick = function() {
      var roll;
      if (this.health < this.maxHealth) {
        this.health += 1;
        if (this.health === this.maxHealth) {
          this.hp = this.maxHp;
          window.simulator.narrate('One of your monsters has recovered.');
        }
      }
      if (this.hp < this.maxHp) {
        roll = Math.floor((Math.random() * 40) + 1);
        if (roll === 40) {
          return this.hp += 1;
        }
      }
    };

    BigMonster.prototype.levelUp = function() {
      this.level += 1;
      window.simulator.narrate('One of your big monsters has attained level ' + this.level.toString() + '!');
      this.hp += 7;
      this.maxHp += 7;
      return this.damage += 1;
    };

    return BigMonster;

  })(Monster);

  Adventurer = (function() {
    function Adventurer() {
      this.hp = 13;
    }

    return Adventurer;

  })();

  Room = (function() {
    function Room() {
      this.population = 0;
      this.size = 5;
      this.occupantType = unitTypes.none;
      this.monsters = [];
    }

    return Room;

  })();

  unitTypes = {
    none: -1,
    minion: 0,
    monster: 1,
    acolyte: 2,
    smallMinion: 3,
    bigMinion: 4,
    smallMonster: 5,
    bigMonster: 6,
    smallAcolyte: 7,
    bigAcolyte: 8
  };

  $(function() {
    window.simulator = new Dungeon;
    return setInterval(window.simulator.tick, 100);
  });

}).call(this);
